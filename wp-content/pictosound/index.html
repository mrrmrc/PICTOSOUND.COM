<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PictoSound - Da Immagine a Musica</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #FF3366;
            --primary-color-rgb: 255, 51, 102;
            --primary-gradient-start: #FF6633;
            --primary-gradient-end: #6633FF;
            --secondary-color: #0033CC;

            --orange-start: #FFA726;
            --orange-end: #FF7043;
            --orange-rgb: 255, 167, 38;

            --accent-color: #06B6D4;
            --accent-color-darker: #0E7490;
            --dark-text: #0A1F44;
            --medium-text: #3A4F66;
            --light-text: #7E8CA0;
            --light-bg: #F5F7FA;
            --card-bg: #FFFFFF;
            --border-color: #D9E2EC;
            --border-radius: 12px;
            --box-shadow: 0 8px 25px rgba(0, 0, 0, 0.08);
            --cues-section-bg: #fcf6ec;
            /* New variable for cues background */
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 15px;
            background-color: var(--light-bg);
            color: var(--dark-text);
            display: flex;
            flex-direction: column;
            align-items: center;
            line-height: 1.6;
        }

        .container {
            background-color: var(--card-bg);
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            width: 100%;
            max-width: 780px;
            margin-bottom: 25px;
            border: 1px solid var(--border-color);
        }

        .logo-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .logo {
            height: 65px;
            width: auto;
        }

        h1 {
            color: var(--dark-text);
            text-align: center;
            margin-top: 5px;
            margin-bottom: 12px;
            font-weight: 700;
            font-size: 2em;
            letter-spacing: -0.5px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.03);
        }

        .subtitle {
            text-align: center;
            color: var(--medium-text);
            margin-bottom: 25px;
            font-size: 1em;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--medium-text);
            font-size: 0.9em;
        }

        .input-actions-container {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            align-items: stretch;
        }

        .input-actions-container input[type="file"],
        .input-actions-container button.icon-button {
            padding: 12px 15px;
            border: 2px dashed var(--accent-color);
            border-radius: var(--border-radius);
            cursor: pointer;
            background-color: #fafcff;
            font-size: 0.9em;
            color: var(--medium-text);
            transition: all 0.2s ease;
            text-align: center;
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .input-actions-container input[type="file"] {
            line-height: 1.5;
            /* Ensures text within the file input is vertically centered if it wraps */
        }

        .input-actions-container button.icon-button {
            background-color: var(--accent-color-darker);
            border-style: solid;
            color: white;
        }

        .input-actions-container button.icon-button svg {
            width: 24px;
            height: 24px;
            margin-bottom: 5px;
            fill: currentColor;
        }


        .input-actions-container input[type="file"]:hover,
        .input-actions-container button.icon-button:hover {
            border-color: var(--primary-color);
            background-color: #fff;
            color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(var(--primary-color-rgb), 0.1);
        }

        .input-actions-container button.icon-button:hover {
            color: white;
            /* Keep text white on hover for icon button */
            background-color: var(--accent-color);
            /* Lighter accent on hover */
        }


        #cameraViewContainer {
            display: none;
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            background-color: #f0f2f5;
            /* Light background for camera view */
        }

        #cameraFeed {
            width: 100%;
            max-width: 400px;
            height: auto;
            border-radius: 8px;
            margin: 0 auto 10px;
            /* Centered, with margin below */
            display: block;
            border: 1px solid var(--border-color);
        }

        .camera-controls {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
            /* Added margin for spacing */
            flex-wrap: wrap;
            /* Allow buttons to wrap on small screens */
        }

        .camera-controls button {
            padding: 10px 15px;
            /* Adjusted padding for potentially smaller buttons */
            font-size: 0.9em;
            /* Adjusted font size */
            background-color: var(--accent-color);
            /* Clear background color */
            color: white;
            /* Clear text color */
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 500;
            transition: background-color 0.2s ease;
            display: inline-flex;
            /* For icon and text alignment */
            align-items: center;
            gap: 5px;
            /* Space between icon and text */
        }

        .camera-controls button svg {
            width: 20px;
            /* Icon size */
            height: 20px;
            fill: currentColor;
        }

        .camera-controls button:hover {
            background-color: var(--accent-color-darker);
            /* Darker on hover */
        }


        #imagePreviewContainer {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 200px;
            background-color: #f0f2f5;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            overflow: hidden;
            position: relative;
            /* For detectionCanvas positioning */
        }

        #imagePreview {
            display: block;
            max-width: 100%;
            max-height: 320px;
            border-radius: calc(var(--border-radius) - 1px);
            /* Inner radius */
        }

        #detectionCanvas {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            /* Allow clicks to pass through to image if needed */
            display: none;
            /* Controlled by JS */
        }

        #mainContentArea {
            margin-top: 20px;
        }

        .action-buttons-container {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 25px;
        }

        .action-buttons-container button {
            margin-top: 0;
            /* Override general button margin if any */
        }

        button {
            color: white;
            border: none;
            padding: 14px 22px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.25s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        button:hover {
            transform: translateY(-3px) scale(1.02);
        }

        button:active {
            transform: translateY(0px) scale(0.98);
        }

        button:disabled {
            background: linear-gradient(135deg, #c5c9d1, #a8afba);
            box-shadow: none;
            color: #777c85;
            cursor: not-allowed;
            transform: none;
        }

        #generateMusicButton {
            background: linear-gradient(135deg, var(--orange-start), var(--orange-end));
            box-shadow: 0 4px 15px rgba(var(--orange-rgb), 0.3);
            width: auto;
            /* Fit content */
            min-width: 250px;
            /* Minimum width */
            color: var(--dark-text);
            /* Ensure text is readable on orange gradient */
        }

        #generateMusicButton:hover {
            box-shadow: 0 7px 20px rgba(var(--orange-rgb), 0.4);
        }

        #generateMusicButton:active {
            box-shadow: 0 3px 10px rgba(var(--orange-rgb), 0.25);
        }


        .spinner {
            display: inline-block;
            width: 1em;
            height: 1em;
            border: 2.5px solid rgba(0, 0, 0, 0.3);
            /* Default spinner color for dark text button */
            border-radius: 50%;
            border-top-color: var(--dark-text);
            /* Matches button text color */
            animation: spin 0.7s linear infinite;
            margin-left: 10px;
            vertical-align: middle;
        }

        #generateMusicButton.loading .spinner {
            /* Spinner when button is loading */
            border-top-color: white;
            /* If button text turns white during loading */
            border: 2.5px solid rgba(255, 255, 255, 0.3);
        }


        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        #dynamicFeedbackArea {
            margin-top: 15px;
            margin-bottom: 20px;
            text-align: center;
        }

        #progressAndPlayerContainer {
            padding: 15px;
            background-color: var(--light-bg);
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            text-align: center;
            min-height: 65px;
            /* Ensure it has some height even when empty */
            display: none;
            /* Initially hidden, shown by JS */
            margin-top: 0;
            /* Reset margin if it was previously set by statusDiv */
        }

        #progressMessage {
            color: var(--dark-text);
            font-size: 0.95em;
            margin-bottom: 12px;
            font-weight: 500;
        }

        #progressMessage:empty {
            display: none;
        }

        .progress-bar-container {
            width: 100%;
            margin: 12px auto;
            background-color: #e9edf2;
            border-radius: 8px;
            height: 12px;
            overflow: hidden;
            display: none;
            /* Shown by JS when loading */
        }

        .progress-bar-animated {
            width: 0;
            height: 100%;
            background: linear-gradient(90deg, var(--accent-color), var(--primary-color), var(--accent-color));
            background-size: 300% 100%;
            animation: progress-animation 2s ease-in-out infinite, fill-progress 15s linear forwards;
            /* Example fill duration */
            border-radius: 8px;
        }

        @keyframes progress-animation {
            0% {
                background-position: 200% 0;
            }

            100% {
                background-position: -200% 0;
            }
        }

        /* Example fill animation, actual progress should be set by JS if possible */
        @keyframes fill-progress {
            0% {
                width: 0%;
            }

            20% {
                width: 30%;
            }

            /* Simulating stages */
            50% {
                width: 60%;
            }

            80% {
                width: 85%;
            }

            100% {
                width: 95%;
            }

            /* Stays a bit shy of 100% until truly complete */
        }


        #status {
            padding: 12px 18px;
            background-color: #eef2f7;
            /* Default info background */
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            text-align: center;
            color: var(--medium-text);
            white-space: pre-wrap;
            /* Allow line breaks in status */
            font-size: 0.9em;
            display: block;
            /* Initially visible for model loading messages */
            margin-bottom: 0;
            /* Adjusted, feedback area will handle spacing */
        }

        #status.hidden {
            /* Utility class to hide if needed by JS */
            display: none;
        }

        .status-error {
            background-color: #ffebee !important;
            border-color: #f44336 !important;
            color: #c62828 !important;
        }

        .status-success {
            background-color: #e8f5e9 !important;
            border-color: #4caf50 !important;
            color: #2e7d32 !important;
        }

        #imageCanvas {
            display: none;
        }

        /* For offscreen image processing */
        #compositeImageCanvas {
            display: none;
        }

        /* For offscreen composite image generation */

        /* AI Insights Section Styling */
        #aiInsightsSection {
            padding: 20px;
            background-color: #fdfdff;
            /* Main section background */
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
            display: none;
            /* Initially hidden */
            margin-top: 20px;
        }

        #aiInsightsSection>h3 {
            /* Main title: COSA VEDE L'AI */
            font-size: 1.35em;
            color: var(--dark-text);
            border-bottom: 2px solid;
            border-image-slice: 1;
            border-image-source: linear-gradient(to right, var(--primary-color), var(--accent-color));
            padding-bottom: 10px;
            margin-top: 0;
            margin-bottom: 10px;
            font-weight: 700;
            text-align: center;
        }

        #aiInterpretationText {
            font-size: 0.95em;
            color: var(--medium-text);
            margin-bottom: 15px;
            text-align: center;
            line-height: 1.5;
        }

        .details-accordion-header {
            font-size: 1.1em;
            color: var(--dark-text);
            background-color: var(--light-bg);
            padding: 10px 15px;
            margin-top: 15px;
            margin-bottom: 0;
            /* Content below will have its own margin/padding */
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }

        .details-accordion-header:hover {
            background-color: #e9edf2;
        }

        .details-accordion-header .toggle-icon::before {
            content: '►';
            /* Right-pointing triangle */
            font-weight: bold;
            color: var(--primary-color);
            font-size: 0.8em;
            transition: transform 0.2s ease-in-out;
            display: inline-block;
        }

        .details-accordion-header.open .toggle-icon::before {
            transform: rotate(90deg);
            /* Down-pointing triangle */
        }

        .new-content-flash>.details-accordion-header {
            /* Target the header directly for flashing */
            animation: flash-border-accordion 0.6s ease-in-out 3;
        }

        @keyframes flash-border-accordion {

            0%,
            100% {
                border-color: var(--border-color);
                box-shadow: none;
            }

            50% {
                border-color: var(--primary-color);
                box-shadow: 0 0 8px rgba(var(--primary-color-rgb), 0.3);
            }
        }


        #aiInsightsContent {
            font-size: 0.9em;
            line-height: 1.65;
            color: var(--medium-text);
            display: none;
            /* Controlled by JS and .open class on header */
            animation: fadeIn 0.3s ease-out;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-top: none;
            /* Avoid double border with header */
            border-radius: 0 0 var(--border-radius) var(--border-radius);
            /* Round bottom corners */
            background-color: #fff;
            /* White background for content area */
        }

        .details-accordion-header.open+#aiInsightsContent {
            /* Show content when header is open */
            display: block;
        }


        .ai-processing-simulation {
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.8em;
            color: var(--light-text);
            height: 2.8em;
            /* Approx 2 lines */
            overflow: hidden;
            border: 1px dashed var(--border-color);
            padding: 5px;
            margin-bottom: 10px;
            border-radius: 4px;
            background-color: var(--light-bg);
        }

        .ai-processing-simulation p {
            margin: 0;
            line-height: 1.4em;
        }


        #aiInsightsContent strong {
            color: var(--dark-text);
            font-weight: 600;
        }

        #aiInsightsContent ul {
            list-style-type: none;
            padding-left: 0;
            margin-top: 5px;
            margin-bottom: 15px;
        }

        #aiInsightsContent ul li {
            padding: 5px 0;
            border-bottom: 1px dashed #e7eaf0;
        }

        #aiInsightsContent ul li:last-child {
            border-bottom: none;
        }

        .color-swatch-inline {
            display: inline-block;
            width: 14px;
            height: 14px;
            border-radius: 3px;
            margin-right: 6px;
            vertical-align: middle;
            border: 1px solid var(--border-color);
        }

        #finalPromptForAI {
            margin-top: 15px;
            padding: 12px;
            background-color: var(--dark-text);
            color: #f0f0f0;
            border-radius: 8px;
            font-family: 'Menlo', 'Monaco', 'Courier New', monospace;
            font-size: 0.88em;
            white-space: pre-wrap;
            word-break: break-word;
            line-height: 1.5;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2) inset;
        }


        .options-section {
            margin-top: 25px;
            padding: 20px;
            background-color: var(--card-bg);
            border-radius: var(--border-radius);
            border: 1px solid var(--border-color);
            box-shadow: var(--box-shadow);
        }

        /* Specific styling for descriptive cues section */
        #descriptiveCuesSection {
            background-color: var(--cues-section-bg);
            /* New background color */
        }

        #descriptiveCuesSection>h3 {
            /* Title: FAI LE TUE PERSONALIZZAZIONI */
            font-size: 1.35em;
            /* Slightly larger */
            color: var(--dark-text);
            border-bottom: 2px solid;
            border-image-slice: 1;
            border-image-source: linear-gradient(to right, var(--primary-color), var(--accent-color));
            padding-bottom: 10px;
            margin-bottom: 10px;
            /* Reduced margin to bring text closer */
            font-weight: 700;
            text-align: center;
        }

        #descriptiveCuesSection .info-text-cues-main {
            /* New class for the moved text */
            font-size: 0.95em;
            /* Slightly larger */
            color: var(--medium-text);
            margin-bottom: 20px;
            /* Space before cue groups */
            text-align: center;
            line-height: 1.5;
        }


        .options-section#durationSection h3 {
            margin-bottom: 10px;
            /* Space above duration options */
        }


        .cues-selection-container {
            margin-bottom: 15px;
        }

        .cues-selection-container:last-child {
            margin-bottom: 0;
        }

        .cues-selection-container label.group-label {
            font-weight: 600;
            color: var(--dark-text);
            margin-bottom: 10px;
            font-size: 1.05em;
            /* Increased font size */
            display: flex;
            /* Use flex for alignment */
            justify-content: space-between;
            /* Pushes icon to the right */
            align-items: center;
            /* Vertical alignment */
            cursor: pointer;
            padding-bottom: 5px;
            /* Space for border */
            border-bottom: 1px dashed var(--border-color);
            transition: color 0.2s ease;
        }

        .cues-selection-container label.group-label:hover {
            color: var(--primary-color);
        }

        .cues-selection-container label.group-label .toggle-icon-cues::before {
            content: '►';
            font-weight: bold;
            color: var(--medium-text);
            /* Consistent with other toggle icons */
            font-size: 0.7em;
            transition: transform 0.2s ease-in-out;
            display: inline-block;
        }

        .cues-selection-container label.group-label.open .toggle-icon-cues::before {
            transform: rotate(90deg);
        }

        .cues-selection-container label.group-label img.cue-icon {
            width: 80px;
            /* Fixed size for icons */
            height: 80px;
            margin-right: 10px;
            vertical-align: middle;
            object-fit: contain;
            /* Ensure icon is not distorted */
            border-radius: 4px;
        }


        .checkbox-pills-group {
            display: none;
            /* Hidden by default, shown by JS */
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
            /* Space below the label */
            animation: fadeIn 0.3s ease-out;
            /* Smooth appearance */
        }

        .checkbox-pills-group.open {
            /* Class added by JS to show */
            display: flex;
        }

        .checkbox-pill {
            display: inline-flex;
            align-items: center;
            padding: 8px 14px;
            border: 1px solid var(--border-color);
            border-radius: 20px;
            /* Pill shape */
            cursor: pointer;
            transition: all 0.2s ease-in-out;
            font-size: 0.9em;
            /* Increased font size */
            background-color: var(--light-bg);
            /* Keep light for contrast on new bg */
            color: var(--medium-text);
            user-select: none;
            /* Prevent text selection on click */
        }

        .checkbox-pill input[type="checkbox"] {
            display: none;
            /* Hide actual checkbox */
        }

        .checkbox-pill:hover {
            border-color: var(--primary-color);
            color: var(--primary-color);
            background-color: #fff;
            /* Lighten on hover */
            transform: translateY(-1px);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.07);
        }

        .checkbox-pill.selected {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-gradient-end));
            color: white;
            border-color: transparent;
            /* Hide border when selected */
            box-shadow: 0 3px 8px rgba(var(--primary-color-rgb), 0.2);
        }

        .checkbox-pill.selected:hover {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-gradient-end));
            /* Keep gradient on hover when selected */
            box-shadow: 0 4px 10px rgba(var(--primary-color-rgb), 0.3);
        }


        .info-text-cues {
            /* This is the old one, now used for the moved text */
            font-size: 0.8em;
            color: var(--medium-text);
            margin-top: 15px;
            text-align: center;
        }

        #audioPlayerContainer h3 {
            font-size: 1.1em;
            /* Standardize heading size */
        }

        audio {
            width: 100%;
            margin-top: 10px;
        }

        #audioInfo {
            font-size: 0.85em;
        }

        #downloadButtonsContainer {
            margin-top: 15px;
            display: flex;
            flex-direction: row;
            /* Default to row */
            justify-content: center;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
            /* Allow wrapping on smaller screens */
        }

        .download-button {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 10px 18px;
            background: linear-gradient(135deg, var(--secondary-color), var(--accent-color));
            color: white;
            text-decoration: none;
            border-radius: var(--border-radius);
            text-align: center;
            font-weight: 500;
            transition: all 0.2s ease;
            font-size: 0.9em;
            box-shadow: 0 3px 8px rgba(0, 51, 204, 0.2);
            flex-shrink: 0;
            /* Prevent buttons from shrinking too much */
        }

        .download-button .button-icon-placeholder img {
            width: 20px;
            height: 20px;
            object-fit: cover;
            border-radius: 3px;
        }

        .download-button svg {
            width: 18px;
            height: 18px;
            fill: currentColor;
        }

        .download-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 12px rgba(0, 51, 204, 0.3);
        }


        .radio-duration-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 0 0 15px 0;
            /* Bottom margin */
            justify-content: center;
        }

        .radio-duration-item {
            min-width: 85px;
            position: relative;
            /* For absolute positioning of radio */
        }

        .radio-duration-item input[type="radio"] {
            position: absolute;
            opacity: 0;
            width: 0;
            height: 0;
        }

        .radio-duration-item label {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 10px 12px;
            font-size: 0.8em;
            text-align: center;
            background-color: var(--card-bg);
            border: 2px solid var(--border-color);
            color: var(--medium-text);
            box-shadow: 0 3px 6px rgba(0, 0, 0, 0.06);
            transition: all 0.25s ease-in-out;
            border-radius: var(--border-radius);
            cursor: pointer;
            width: 100%;
            /* Fill item width */
            box-sizing: border-box;
            /* Include padding and border in width */
            height: 100%;
            /* Fill item height */
        }

        .radio-duration-item label:hover {
            border-color: var(--accent-color);
            color: var(--accent-color-darker);
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.08);
        }

        .radio-duration-item input[type="radio"]:checked+label {
            background: linear-gradient(135deg, var(--primary-color), var(--primary-gradient-end));
            border-color: transparent;
            color: white;
            box-shadow: 0 5px 15px rgba(var(--primary-color-rgb), 0.3);
            transform: translateY(-1px) scale(1.03);
        }

        .radio-duration-item input[type="radio"]:focus-visible+label {
            /* Accessibility */
            outline: 2px solid var(--primary-color);
            outline-offset: 2px;
        }

        .radio-duration-item label .duration-value {
            font-size: 0.95em;
            font-weight: 600;
            display: block;
        }

        .radio-duration-item label .duration-credit {
            font-size: 0.75em;
            display: block;
            margin-top: 2px;
            opacity: 0.8;
        }

        .radio-duration-item input[type="radio"]:checked+label .duration-credit {
            opacity: 1;
        }

        .bpm-slider-container {
            margin-top: 15px;
            margin-bottom: 10px;
            display: none;
            /* Hidden by default, shown by JS */
        }

        /* Show BPM slider when its corresponding pill group is open */
        .cues-selection-container label.group-label.open+.checkbox-pills-group+.bpm-slider-container,
        .cues-selection-container label.group-label.open+.bpm-slider-container {
            /* If no pills group, direct sibling */
            display: block;
        }

        .bpm-slider-container label {
            font-weight: 500;
            color: var(--dark-text);
            font-size: 0.9em;
            margin-bottom: 8px;
        }

        .bpm-slider-container input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--primary-color);
            /* Modern way to style slider thumb/track */
        }

        .bpm-slider-container #bpmValue {
            display: inline-block;
            margin-left: 10px;
            font-weight: 600;
            color: var(--primary-color);
        }

        #fullscreenImageModal {
            display: none;
            /* Hidden by default */
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            /* Enable scroll if needed, though image should fit */
            background-color: rgba(0, 0, 0, 0.9);
            /* Dark overlay */
            justify-content: center;
            /* Center image horizontally */
            align-items: center;
            /* Center image vertically */
        }

        #fullscreenImage {
            margin: auto;
            display: block;
            max-width: 90%;
            max-height: 90%;
            border-radius: 8px;
            /* Optional: rounded corners for the image */
        }

        #closeFullscreenButton {
            position: absolute;
            top: 20px;
            right: 35px;
            color: #f1f1f1;
            font-size: 40px;
            font-weight: bold;
            transition: 0.3s;
            cursor: pointer;
            user-select: none;
        }

        #closeFullscreenButton:hover,
        #closeFullscreenButton:focus {
            color: #bbb;
            text-decoration: none;
        }


        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.7em;
            }

            .subtitle {
                font-size: 0.95em;
            }

            .radio-duration-item {
                min-width: 80px;
            }

            #downloadButtonsContainer {
                flex-direction: column;
                /* Stack download buttons on smaller screens */
            }
        }

        @media (max-width: 480px) {
            body {
                padding: 10px;
            }

            .container {
                padding: 10px;
            }

            h1 {
                font-size: 1.5em;
            }

            .subtitle {
                font-size: 0.9em;
            }

            button {
                padding: 12px 18px;
                font-size: 0.95em;
            }

            .input-actions-container {
                flex-direction: column;
            }

            .input-actions-container input[type="file"],
            .input-actions-container button#takePictureButton {
                margin-bottom: 10px;
                /* Add space when stacked */
            }

            .options-section {
                padding: 10px;
            }

            .checkbox-pills-group {
                gap: 6px;
            }

            .checkbox-pill {
                padding: 7px 10px;
                font-size: 0.8em;
            }

            .radio-duration-item {
                min-width: 70px;
            }

            .radio-duration-item label {
                padding: 8px 10px;
                font-size: 0.75em;
            }
        }
    </style>
    <script src="js/tf.min.js" crossorigin="anonymous"></script>
    <script src="js/coco-ssd.min.js" crossorigin="anonymous"></script>
    <script src="js/face-api.min.js" crossorigin="anonymous"></script>
    <script src="js/qrcode.min.js"></script>
</head>

<body>
    <div class="logo-container">
        <img src="icone/logo.png" alt="PictoSound Logo" class="logo"
            onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyMDAiIGhlaWdodD0iODAiIHZpZXdCb3g9IjAgMCAyMDAgODAiPgogIDxkZWZzPgogICAgPGxpbmVhckdyYWRpZW50IGlkPSJncmFkMSIgeDE9IjAlIiB5MT0iMCUiIHgyPSIxMDAlIiB5Mj0iMTAwJSI+CiAgICAgIDxzdG9wIG9mZnNldD0iMCUiIHN0eWxlPSJzdG9wLWNvbG9yOiNGRjY2MzM7c3RvcC1vcGFjaXR5OjEiIC8+CiAgICAgIDxzdG9wIG9mZnNldD0iMTAwJSIgc3R5bGU9InN0b3AtY29sb3I6IzY2MzNGRjtzdG9wLW9wYWNpdHk6MSIgLz4KICAgIDwvbGluZWFyR3JhZGllbnQ+CiAgICA8bGluZWFyR3JhZGllbnQgaWQ9ImdyYWQyIiB4MT0iMCUiIHkxPSIwJSIgeDI9IjEwMCUiIHkyPSIxMDAlIj4KICAgICAgPHN0b3Agb2Zmc2V0PSIwJSIgc3R5bGU9InN0b3AtY29sb3I6IzAwMzNDQztzdG9wLW9wYWNpdHk6MSIgLz4KICAgICAgPHN0b3Agb2Zmc2V0PSIxMDAlIiBzdHlsZT0ic3RvcC1jb2xvcjojMzNDQ0ZGO3N0b3Atb3BhY2l0eToxIiAvPgogICAgPC9saW5lYXJHcmFkaWVudD4KICA8L2RlZnM+CiAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoNDMsIDEwKSI+CiAgICA8cGF0aCBkPSJNMCwwIEwwLDQwIEw0MCw0MCBMNDAsNSBMMTUsNSBMNSwxNSBMNSw1IEwwLDAgWiIgZmlsbD0idXJsKCNncmFkMSkiLz4KICAgIDxjaXJjbGUgY3g9IjE1IiBjeT0iMTUiIHI9IjUiIGZpbGw9InVybCgjZ3JhZDEpIi8+CiAgICA8cGF0aCBkPSJNNDAsNSBDNTAsMTUgNTAsMjUgNDAsNDAgTDUwLDQwIEM1NSwyNSA1NSwxNSA1MCw1IEw0MCw1IFoiIGZpbGw9InVybCgjZ3JhZDEpIi8+CiAgICA8cGF0aCBkPSJNNzAsMjAgQzczLDIwIDc2LDIzIDc2LDI2IEM3NiwyOSA3MywzMiA3MCwzMiBDNjcsMzIgNjQsMjkgNjQsMjYgQzY0LDIzIDY3LDIwIDcwLDIwIFoiIGZpbGw9InVybCgjZ3JhZDIpIi8+CiAgICA8cGF0aCBkPSJNODAsMTUgQzg0LDE1IDg4LDE5IDg4LDI1IEM4OCwzMSA4NCwzNSA4MCwzNSBDNzYsMzUgNzIsMzEgNzIsMjUgQzcyLDE5IDc2LDE1IDgwLDE1IFoiIGZpbGw9InVybCgjZ3JhZDIpIiBmaWxsLW9wYWNpdHk9IjAuOCIvPgogICAgPHBhdGggZD0iTTkwLDEwIEM5NSwxMCAxMDAsMTYgMTAwLDI1IEMxMDAsMzQgOTUsNDAgOTAsNDAgQzg1LDQwIDgwLDM0IDgwLDI1IEM4MCwxNiA4NSwxMCA5MCwxMCBaIiBmaWxsPSJ1cmwoI2dyYWQyKSIgZmlsbC1vcGFjaXR5PSIwLjYiLz4KICA8L2c+CiAgPHRleHQgeD0iMjUiIHk9IjY1IiBmb250LWZhbWlseT0iQXJpYWwiIGZvbnQtc2l6ZT0iMjIiIGZvbnQtd2VpZ2h0PSJib2xkIiBmaWxsPSIjMEExRjQ0Ij5QaWN0b1NvdW5kPC90ZXh0Pgo8L3N2Zz4='; this.onerror=null;">
    </div>

    <div class="container">
        <h1>TRASFORMA L'IMMAGINE IN MUSICA</h1>
        <p class="subtitle">Lascia che l'AI analizzi l'immagine e la trasformi in esperienza sonora. Da oggi anche le
            immagini hanno un suono</p>

        <div class="options-section">
            <h3>1. Scegli la tua Immagine</h3>
            <div class="input-actions-container">
                <input type="file" id="imageUpload" accept="image/*" title="Carica un file immagine">
                <button id="takePictureButton" class="icon-button" title="Usa la fotocamera">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor" width="24"
                        height="24">
                        <path
                            d="M4 4h3l2-2h6l2 2h3v16H4V4zm8 13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm0-8c1.66 0 3 1.34 3 3s-1.34 3-3 3-3-1.34-3-3 1.34-3 3-3z" />
                    </svg>
                    Scatta Foto
                </button>
            </div>
            <div id="cameraViewContainer">
                <video id="cameraFeed" autoplay playsinline></video>
                <div class="camera-controls">
                    <button id="captureImageButton">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                            <path
                                d="M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0-6c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2z" />
                            <path
                                d="M4 4h3l2-2h6l2 2h3v16H4V4zm8 13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5z"
                                opacity=".3" />
                            <path
                                d="M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm0 18H4V4h3l2-2h6l2 2h3v16z" />
                        </svg>
                        Scatta!
                    </button>
                    <button id="switchCameraButton" title="Cambia Fotocamera">
                        <svg xmlns="http://www.w3.org/2000/svg" height="20px" viewBox="0 0 24 24" width="20px"
                            fill="currentColor">
                            <path d="M0 0h24v24H0V0z" fill="none" />
                            <path
                                d="M20 5h-3.17L15 3H9L7.17 5H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V7c0-1.1-.9-2-2-2zm-5 11.5V13H9v2.5L5.5 12 9 8.5V11h6V8.5l3.5 3.5-3.5 3.5z" />
                        </svg>
                        Cambia
                    </button>
                    <button id="closeCameraButton">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                            <path
                                d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" />
                        </svg>
                        Annulla
                    </button>
                </div>
            </div>
            <div id="imagePreviewContainer">
                <img id="imagePreview" src="#" alt="Anteprima Immagine" style="display:none;">
                <canvas id="detectionCanvas" style="display:none;"></canvas>
            </div>
        </div>

        <div id="mainContentArea">
            <div class="options-section" id="durationSection">
                <h3>2. Durata Musica</h3>
                <div class="radio-duration-group">
                    <div class="radio-duration-item">
                        <input type="radio" id="duration40" name="musicDuration" value="40" checked>
                        <label for="duration40">
                            <span class="duration-value">40s</span>
                            <span class="duration-credit">FREE</span>
                        </label>
                    </div>
                    <div class="radio-duration-item">
                        <input type="radio" id="duration60" name="musicDuration" value="60">
                        <label for="duration60">
                            <span class="duration-value">60s</span>
                            <span class="duration-credit">1 cr.</span>
                        </label>
                    </div>
                    <div class="radio-duration-item">
                        <input type="radio" id="duration120" name="musicDuration" value="120">
                        <label for="duration120">
                            <span class="duration-value">120s</span>
                            <span class="duration-credit">2 cr.</span>
                        </label>
                    </div>
                    <div class="radio-duration-item">
                        <input type="radio" id="duration180" name="musicDuration" value="180">
                        <label for="duration180">
                            <span class="duration-value">180s</span>
                            <span class="duration-credit">3 cr.</span>
                        </label>
                    </div>
                    <div class="radio-duration-item">
                        <input type="radio" id="duration240" name="musicDuration" value="240">
                        <label for="duration240">
                            <span class="duration-value">240s</span>
                            <span class="duration-credit">4 cr.</span>
                        </label>
                    </div>
                    <div class="radio-duration-item">
                        <input type="radio" id="duration360" name="musicDuration" value="360">
                        <label for="duration360">
                            <span class="duration-value">360s</span>
                            <span class="duration-credit">5 cr.</span>
                        </label>
                    </div>
                </div>
            </div>

            <div class="action-buttons-container">
                <button id="generateMusicButton" disabled>Avvia generazione musica <span id="musicSpinner"
                        style="display:none;" class="spinner"></span></button>
            </div>

            <div id="dynamicFeedbackArea">
                <div id="status" class="status-message" style="margin-bottom: 15px;">In attesa del caricamento dei
                    modelli AI...</div>
                <div id="progressAndPlayerContainer">
                    <div id="progressMessage"></div>
                    <div class="progress-bar-container" id="progressBarContainer">
                        <div class="progress-bar-animated" id="progressBarAnimated"></div>
                    </div>
                    <div id="audioPlayerContainer">
                        <h3>Musica Generata</h3>
                        <audio id="audioPlayer" controls src=""></audio>
                        <p id="audioInfo"></p>
                        <div id="downloadButtonsContainer">
                            <a id="downloadAudioLink" href="#" class="download-button" style="display:none;">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"
                                    width="18" height="18">
                                    <path
                                        d="M19.35 10.04A7.49 7.49 0 0 0 12 4C9.11 4 6.6 5.64 5.35 8.04A5.994 5.994 0 0 0 0 14a6 6 0 0 0 6 6h13a5 5 0 0 0 5-5c0-2.64-2.05-4.78-4.65-4.96zM17 13l-5 5-5-5h3V9h4v4h3z" />
                                </svg>
                                Scarica Audio
                            </a>
                            <a id="downloadCompositeImageLink" href="#" class="download-button" style="display:none;">
                                <span class="button-icon-placeholder">
                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"
                                        width="18" height="18">
                                        <path d="M5 20h14v-2H5v2zm14-9h-4V3H9v8H5l7 7 7-7z" />
                                    </svg>
                                </span>
                                Scarica Img+QR
                            </a>
                            <a id="downloadQrOnlyLink" href="#" class="download-button" style="display:none;">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"
                                    width="18" height="18">
                                    <path
                                        d="M3 11h8V3H3v8zm2-6h4v4H5V5zm8-2v8h8V3h-8zm6 6h-4V5h4v4zM3 21h8v-8H3v8zm2-6h4v4H5v-4zm13-2h-2v3h-3v2h5v-5zM13 3h2v2h-2V3zm0 16h2v2h-2v-2zm-5-5h2v2H8v-2z" />
                                </svg>
                                Scarica QR
                            </a>
                        </div>
                    </div>
                </div>
            </div>

            <div id="aiInsightsSection" class="options-section">
                <h3>COSA VEDE L'AI</h3>
                <p id="aiInterpretationText">L'intelligenza artificiale ha analizzato la tua immagine per coglierne
                    l'essenza e trasformarla in musica. Ecco come ha interpretato gli elementi visivi:</p>
                <div class="details-accordion-header">
                    <span>Dettagli</span>
                    <span class="toggle-icon"></span>
                </div>
                <div id="aiInsightsContent">
                    <div class="ai-processing-simulation" id="aiProcessingSimulation">
                        <p>In attesa di analisi immagine...</p>
                    </div>
                </div>
            </div>

            <div class="options-section" id="descriptiveCuesSection">
                <h3>FAI LE TUE PERSONALIZZAZIONI <span
                        style="font-weight:normal; font-size:0.8em; color:var(--light-text);">(opzionale)</span></h3>
                <p class="info-text-cues-main">L'IA genererà la musica anche senza selezioni, basandosi sull'immagine.
                    Le tue scelte aiuteranno a guidare l'interpretazione.</p>

                <div class="cues-selection-container">
                    <label class="group-label collapsible-cue-header" for="moodPills">
                        <img src="icone/mood_icon.jpg" alt="Mood Icona" class="cue-icon"
                            onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij48cmVjdCB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHN0eWxlPSJmaWxsOiNjY2M7Ii8+PC9zdmc+'; this.onerror=null;">
                        Mood (felice, triste, epico, rilassante, ecc...): <span class="toggle-icon-cues"></span>
                    </label>
                    <div class="checkbox-pills-group" id="moodPills">
                    </div>
                    <div class="bpm-slider-container">
                        <label for="bpmSlider">BPM (circa): <span id="bpmValue">120</span></label>
                        <input type="range" id="bpmSlider" name="bpm" min="40" max="200" value="120" step="5">
                    </div>
                </div>
                <div class="cues-selection-container">
                    <label class="group-label collapsible-cue-header" for="genrePills">
                        <img src="icone/genere_icon.jpg" alt="Genere Icona" class="cue-icon"
                            onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij48cmVjdCB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHN0eWxlPSJmaWxsOiNjY2M7Ii8+PC9zdmc+'; this.onerror=null;">
                        Genere (Elettronica, Dance, Rock, Pop, Jazz, ecc..): <span class="toggle-icon-cues"></span>
                    </label>
                    <div class="checkbox-pills-group" id="genrePills">
                    </div>
                </div>
                <div class="cues-selection-container">
                    <label class="group-label collapsible-cue-header" for="instrumentPills">
                        <img src="icone/strumenti_icon.jpg" alt="Strumenti Icona" class="cue-icon"
                            onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij48cmVjdCB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHN0eWxlPSJmaWxsOiNjY2M7Ii8+PC9zdmc+'; this.onerror=null;">
                        Strumenti (pianoforte, chitarra, basso, ecc...): <span class="toggle-icon-cues"></span>
                    </label>
                    <div class="checkbox-pills-group" id="instrumentPills">
                    </div>
                </div>
                <div class="cues-selection-container">
                    <label class="group-label collapsible-cue-header" for="rhythmPills">
                        <img src="icone/ritmo_icon.jpg" alt="Ritmo Icona" class="cue-icon"
                            onerror="this.src='data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxNiIgaGVpZ2h0PSIxNiIgdmlld0JveD0iMCAwIDE2IDE2Ij48cmVjdCB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHN0eWxlPSJmaWxsOiNjY2M7Ii8+PC9zdmc+'; this.onerror=null;">
                        Ritmo/Groove: <span class="toggle-icon-cues"></span>
                    </label>
                    <div class="checkbox-pills-group" id="rhythmPills">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="fullscreenImageModal">
        <span id="closeFullscreenButton">&times;</span>
        <img id="fullscreenImage" src="#" alt="Immagine ingrandita">
    </div>

    <canvas id="imageCanvas" style="display:none;"></canvas>
    <canvas id="compositeImageCanvas" style="display:none;"></canvas>
    <textarea id="additionalCuesTextarea" style="display:none;"></textarea>
    </div>

    <script>
        // console.log("LOG MOLTO INIZIALE: Lo script sta iniziando a essere interpretato.");

        document.addEventListener('DOMContentLoaded', async () => {
            console.log("LOG: DOMContentLoaded - Pagina pronta e script principale in esecuzione.");

            const CREATIVITY_LEVEL = 50; // Example creativity level

            // Cache DOM elements for performance and convenience
            const domElements = {
                statusDiv: document.getElementById('status'),
                dynamicFeedbackArea: document.getElementById('dynamicFeedbackArea'),
                progressAndPlayerContainer: document.getElementById('progressAndPlayerContainer'),
                progressMessage: document.getElementById('progressMessage'),
                progressBarContainer: document.getElementById('progressBarContainer'),
                progressBarAnimated: document.getElementById('progressBarAnimated'),
                imageUpload: document.getElementById('imageUpload'),
                takePictureButton: document.getElementById('takePictureButton'),
                cameraViewContainer: document.getElementById('cameraViewContainer'),
                cameraFeed: document.getElementById('cameraFeed'),
                captureImageButton: document.getElementById('captureImageButton'),
                switchCameraButton: document.getElementById('switchCameraButton'), // Added switch camera button
                closeCameraButton: document.getElementById('closeCameraButton'),
                imageCanvas: document.getElementById('imageCanvas'), // For analysis
                compositeImageCanvas: document.getElementById('compositeImageCanvas'), // For image + QR
                imagePreview: document.getElementById('imagePreview'),
                detectionCanvas: document.getElementById('detectionCanvas'), // For visual detections
                generateMusicButton: document.getElementById('generateMusicButton'),
                musicSpinner: document.getElementById('musicSpinner'),
                moodPillsContainer: document.getElementById('moodPills'),
                genrePillsContainer: document.getElementById('genrePills'),
                instrumentPillsContainer: document.getElementById('instrumentPills'),
                rhythmPillsContainer: document.getElementById('rhythmPills'),
                bpmSlider: document.getElementById('bpmSlider'),
                bpmValueDisplay: document.getElementById('bpmValue'),
                aiInsightsSection: document.getElementById('aiInsightsSection'),
                aiInterpretationText: document.getElementById('aiInterpretationText'),
                detailsAccordionHeader: document.querySelector('.details-accordion-header'),
                aiInsightsContent: document.getElementById('aiInsightsContent'),
                aiProcessingSimulationDiv: document.getElementById('aiProcessingSimulation'),
                audioPlayerContainer: document.getElementById('audioPlayerContainer'),
                audioPlayer: document.getElementById('audioPlayer'),
                audioInfo: document.getElementById('audioInfo'),
                downloadAudioLink: document.getElementById('downloadAudioLink'),
                downloadCompositeImageLink: document.getElementById('downloadCompositeImageLink'),
                downloadQrOnlyLink: document.getElementById('downloadQrOnlyLink'),
                fullscreenImageModal: document.getElementById('fullscreenImageModal'),
                fullscreenImage: document.getElementById('fullscreenImage'),
                closeFullscreenButton: document.getElementById('closeFullscreenButton')
            };

            // Contexts for canvases
            const detectionCtx = domElements.detectionCanvas.getContext('2d');
            const imageAnalysisCtx = domElements.imageCanvas.getContext('2d');

            // State variables
            let currentImage = null; // Holds the Image object for processing
            let currentImageSrc = null; // Holds the Data URL of the current image
            let currentStream = null; // Holds the camera stream
            let currentFacingMode = "environment"; // "environment" for rear, "user" for front
            let imageAnalysisResults = null; // Stores results from TFJS, color analysis etc.
            let stableAudioPromptForMusic = ""; // The final prompt sent to the music generation API
            let cocoSsdModel = null;
            let faceApiModelLoaded = false;
            const showDetections = false; // Set to true to draw bounding boxes (primarily for debugging)
            let initialPreselectionDoneForCurrentImage = false; // Tracks if AI has preselected cues for the current image

            // Italian to English translations for objects and emotions (used by TFJS models)
            const objectTranslations = {
                "person": "persona", "cat": "gatto", "dog": "cane", "car": "auto", "tree": "albero",
                "book": "libro", "toothbrush": "spazzolino", "laptop": "laptop", "cell phone": "cellulare",
                "keyboard": "tastiera", "mouse": "mouse", "remote": "telecomando", "tv": "televisione",
                "bicycle": "bicicletta", "motorcycle": "motocicletta", "airplane": "aeroplano", "bus": "autobus",
                "train": "treno", "truck": "camion", "boat": "barca", "traffic light": "semaforo",
                "fire hydrant": "idrante", "stop sign": "segnale di stop", "parking meter": "parchimetro",
                "bench": "panchina", "bird": "uccello", "horse": "cavallo", "sheep": "pecora",
                "cow": "mucca", "elephant": "elefante", "bear": "orso", "zebra": "zebra", "giraffe": "giraffa",
                "backpack": "zaino", "umbrella": "ombrello", "handbag": "borsetta", "tie": "cravatta",
                "suitcase": "valigia", "frisbee": "frisbee", "skis": "sci", "snowboard": "snowboard",
                "sports ball": "palla sportiva", "kite": "aquilone", "baseball bat": "mazza da baseball",
                "baseball glove": "guanto da baseball", "skateboard": "skateboard", "surfboard": "tavola da surf",
                "tennis racket": "racchetta da tennis", "bottle": "bottiglia", "wine glass": "bicchiere da vino",
                "cup": "tazza", "fork": "forchetta", "knife": "coltello", "spoon": "cucchiaio", "bowl": "ciotola",
                "banana": "banana", "apple": "mela", "sandwich": "panino", "orange": "arancia",
                "broccoli": "broccoli", "carrot": "carota", "hot dog": "hot dog", "pizza": "pizza",
                "donut": "ciambella", "cake": "torta", "chair": "sedia", "couch": "divano",
                "potted plant": "pianta in vaso", "bed": "letto", "dining table": "tavolo da pranzo", "toilet": "toilette",
            };
            const emotionTranslations = { "neutral": "neutrale", "happy": "felice", "sad": "triste", "angry": "arrabbiato/a", "fearful": "impaurito/a", "disgusted": "disgustato/a", "surprised": "sorpreso/a" };

            // Cue translations for building the English prompt for the music API
            const cueTranslationsITtoEN = {
                mood: {
                    "felice": "happy", "gioioso": "joyful", "triste": "sad", "malinconico": "melancholic", "riflessivo": "reflective",
                    "epico": "epic", "grandioso": "grandiose", "rilassante": "relaxing", "calmo": "calm",
                    "energico": "energetic", "vivace": "lively", "misterioso": "mysterious", "inquietante": "eerie",
                    "sognante": "dreamy", "etereo": "ethereal", "romantico": "romantic", "drammatico": "dramatic",
                    "futuristico": "futuristic", "sci-fi": "sci-fi", "nostalgico": "nostalgic", "potente": "powerful", "intenso": "intense",
                    "descrittivo": "descriptive", "oscuro": "dark", "profondo": "deep", "brillante": "bright", "luminoso": "luminous",
                    "tenue": "muted", "desaturato": "desaturated", "vibrante": "vibrant", "saturo": "saturated",
                    "morbido": "soft", "sfumato": "blurred", "netto": "sharp", "dinamico": "dynamic",
                    "atmosferico": "atmospheric", "contemplativo": "contemplative", "meravigliato": "wondrous", "anticipatorio": "anticipatory",
                    "sospeso": "suspenseful"
                },
                genre: {
                    "elettronica": "electronic", "dance": "dance", "edm": "EDM", "rock": "rock", "pop": "pop", "jazz": "jazz",
                    "classica": "classical", "ambient": "ambient", "soundtrack": "soundtrack", "cinematografica": "cinematic",
                    "folk": "folk", "acustica": "acoustic", "lo-fi": "lo-fi", "chillhop": "chillhop", "hip-hop": "hip hop",
                    "funk": "funk", "soul": "soul", "metal": "metal", "reggae": "reggae", "blues": "blues",
                    "world": "world music", "etnica": "ethnic music", "folk acustico": "acoustic folk", "ambient naturale": "natural ambient",
                    "urban jazz": "urban jazz", "lo-fi hip hop": "lo-fi hip hop"
                },
                instrument: {
                    "pianoforte": "piano", "chitarra acustica": "acoustic guitar", "chitarra elettrica": "electric guitar",
                    "basso": "bass", "batteria": "drums", "percussioni": "percussion", "violino": "violin", "archi": "strings",
                    "violoncello": "cello", "sassofono": "saxophone", "tromba": "trumpet", "ottoni": "brass instruments", "flauto": "flute",
                    "sintetizzatore": "synthesizer", "tastiere": "keyboards", "organo": "organ", "arpa": "harp", "ukulele": "ukulele",
                    "voce umana (cori o effetti)": "human voice (choir or effects)", "voce solista (da definire)": "solo voice", "voce solista": "solo voice",
                    "nessuno strumento specifico": "", // Empty string if no specific instrument is desired
                    "basso profondo": "deep bass", "flauto brillante": "bright flute", "glockenspiel": "glockenspiel",
                    "pad eterei": "ethereal pads", "chitarra con riverbero": "guitar with reverb",
                    "chitarra elettrica con overdrive leggero": "electric guitar with light overdrive", "sassofono contralto": "alto saxophone",
                    "sintetizzatore lead malinconico": "melancholic lead synthesizer", "archi lenti": "slow strings", "clarinetto": "clarinet"
                },
                rhythm: { // These are more descriptive phrases
                    "no_rhythm": "no distinct rhythm", "ambientale": "ambient rhythm",
                    "slow_rhythm": "slow rhythm", "rilassato": "relaxed rhythm",
                    "moderate_groove": "moderate groove", "orecchiabile": "catchy rhythm",
                    "upbeat_energetic": "upbeat energetic rhythm",
                    "complex_experimental_rhythm": "complex experimental rhythm"
                },
                object: {}, // Populated from objectTranslations
                tonality: {
                    "maggiore": "major", "minore": "minor", "misto": "" // Misto implies no specific tonality or a mix
                },
                general: { // General terms that might be used across categories
                    "descrittivo": "descriptive", "lento": "slow", "moderato": "moderate", "veloce": "fast",
                    "strumentale": "instrumental"
                }
            };
            // Populate object translations for cue system
            for (const key in objectTranslations) {
                cueTranslationsITtoEN.object[objectTranslations[key].toLowerCase()] = key.replace("_en", ""); // Store IT as key, EN as value
            }


            // Helper function to translate cues to English for the API prompt
            function translateCueToEnglish(italianCue, type) {
                if (!italianCue) return "";
                const lowerCue = String(italianCue).toLowerCase();

                if (type === 'object' && cueTranslationsITtoEN.object[lowerCue]) {
                    return cueTranslationsITtoEN.object[lowerCue];
                }
                if (cueTranslationsITtoEN[type] && cueTranslationsITtoEN[type][lowerCue]) {
                    return cueTranslationsITtoEN[type][lowerCue];
                }
                if (cueTranslationsITtoEN.general[lowerCue]) { // Fallback to general terms
                    return cueTranslationsITtoEN.general[lowerCue];
                }
                console.warn(`No English translation for '${italianCue}' of type '${type}'. Using original.`);
                return italianCue; // Return original if no translation found
            }


            // Data for checkbox pills (cues)
            const moodItems = [
                { value: "felice", label: "Felice / Gioioso" }, { value: "triste", label: "Triste / Malinconico" }, { value: "riflessivo", label: "Riflessivo" },
                { value: "epico", label: "Epico / Grandioso" }, { value: "rilassante", label: "Rilassante / Calmo" },
                { value: "energico", label: "Energico / Vivace" }, { value: "misterioso", label: "Misterioso / Inquietante" },
                { value: "sognante", label: "Sognante / Etereo" }, { value: "romantico", label: "Romantico" },
                { value: "drammatico", label: "Drammatico" }, { value: "futuristico", label: "Futuristico / Sci-Fi" },
                { value: "nostalgico", label: "Nostalgico" }, { value: "potente", label: "Potente / Intenso" },
                { value: "meravigliato", label: "Meravigliato" }, { value: "anticipatorio", label: "Anticipatorio" }, { value: "sospeso", label: "Sospeso" }
            ];
            const genreItems = [
                { value: "elettronica", label: "Elettronica" }, { value: "dance", label: "Dance / EDM" },
                { value: "rock", label: "Rock" }, { value: "pop", label: "Pop" }, { value: "jazz", label: "Jazz" },
                { value: "classica", label: "Classica" }, { value: "ambient", label: "Ambient" },
                { value: "soundtrack", label: "Soundtrack / Cinematografica" }, { value: "folk", label: "Folk / Acustica" }, { value: "folk acustico", label: "Folk Acustico" }, { value: "ambient naturale", label: "Ambient Naturale" },
                { value: "lo-fi", label: "Lo-fi / Chillhop" }, { value: "hip-hop", label: "Hip Hop" }, { value: "lo-fi hip hop", label: "Lo-fi Hip Hop" },
                { value: "funk", label: "Funk / Soul" }, { value: "metal", label: "Metal" },
                { value: "reggae", label: "Reggae" }, { value: "blues", label: "Blues" },
                { value: "world", label: "World Music / Etnica" }, { value: "urban jazz", label: "Urban Jazz" }
            ];
            const instrumentItems = [
                { value: "pianoforte", label: "Pianoforte" }, { value: "chitarra acustica", label: "Chitarra Acustica" },
                { value: "chitarra elettrica", label: "Chitarra Elettrica" }, { value: "basso", label: "Basso" }, { value: "basso profondo", label: "Basso Profondo" },
                { value: "batteria", label: "Batteria / Percussioni" }, { value: "violino", label: "Violino / Archi" }, { value: "archi lenti", label: "Archi Lenti" },
                { value: "violoncello", label: "Violoncello" }, { value: "sassofono", label: "Sassofono" }, { value: "sassofono contralto", label: "Sassofono Contralto" },
                { value: "tromba", label: "Tromba / Ottoni" }, { value: "flauto", label: "Flauto" }, { value: "flauto brillante", label: "Flauto Brillante" }, { value: "clarinetto", label: "Clarinetto" },
                { value: "sintetizzatore", label: "Sintetizzatore / Tastiere" }, { value: "sintetizzatore lead malinconico", label: "Synth Lead Malinconico" },
                { value: "organo", label: "Organo" }, { value: "arpa", label: "Arpa" }, { value: "ukulele", label: "Ukulele" },
                { value: "voce umana (cori o effetti)", label: "Voce umana (cori o effetti)" }, { value: "voce solista", label: "Voce Solista" },
                { value: "glockenspiel", label: "Glockenspiel" }, { value: "pad eterei", label: "Pad Eterei" },
                { value: "chitarra con riverbero", label: "Chitarra con Riverbero" }, { value: "chitarra elettrica con overdrive leggero", label: "Chitarra Elettrica Overdrive Leggero" },
                { value: "nessuno strumento specifico", label: "Nessuno strumento specifico" }
            ];
            const rhythmItems = [
                { value: "no_rhythm", label: "Nessun ritmo evidente (Ambientale)" },
                { value: "slow_rhythm", label: "Ritmo Lento e Rilassato" },
                { value: "moderate_groove", label: "Groove Moderato e Orecchiabile" },
                { value: "upbeat_energetic", label: "Ritmo Incalzante ed Energico" },
                { value: "complex_experimental_rhythm", label: "Ritmo Complesso / Sperimentale" }
            ];

            // AI Processing Simulation Text
            let simulatedProcessingInterval;
            const simulatedProcessingMessages = [
                "Analisi contorni e forme...", "Estrazione pattern visivi...", "Valutazione composizione cromatica...",
                "Identificazione elementi chiave...", "Interpretazione atmosfera generale...", "Ricerca corrispondenze emotive...",
                "Elaborazione palette sonora...", "Definizione struttura armonica...", "Sviluppo linea melodica...",
                "Costruzione del paesaggio sonoro..."
            ];
            let currentMessageIndex = 0;

            function startAISimulationText() {
                const simulationDiv = domElements.aiInsightsContent.querySelector('.ai-processing-simulation');
                // Ensure the simulation div exists or create it if necessary
                if (!simulationDiv && domElements.aiInsightsContent) {
                    const newSimDiv = document.createElement('div');
                    newSimDiv.classList.add('ai-processing-simulation');
                    newSimDiv.id = 'aiProcessingSimulation'; // Ensure it has the ID if recreated
                    domElements.aiInsightsContent.prepend(newSimDiv); // Prepend to keep it at the top
                    domElements.aiProcessingSimulationDiv = newSimDiv; // Update cache
                } else if (simulationDiv) {
                    simulationDiv.innerHTML = ''; // Clear previous content
                }

                if (domElements.aiProcessingSimulationDiv) { // Check if it's available
                    domElements.aiProcessingSimulationDiv.style.display = 'block';
                    let line1 = document.createElement('p');
                    let line2 = document.createElement('p');
                    domElements.aiProcessingSimulationDiv.appendChild(line1);
                    domElements.aiProcessingSimulationDiv.appendChild(line2);

                    currentMessageIndex = 0;
                    line1.textContent = simulatedProcessingMessages[currentMessageIndex % simulatedProcessingMessages.length];
                    line2.textContent = simulatedProcessingMessages[(currentMessageIndex + 1) % simulatedProcessingMessages.length];

                    simulatedProcessingInterval = setInterval(() => {
                        currentMessageIndex++;
                        line1.textContent = simulatedProcessingMessages[currentMessageIndex % simulatedProcessingMessages.length];
                        line2.textContent = simulatedProcessingMessages[(currentMessageIndex + 1) % simulatedProcessingMessages.length];
                    }, 1500);
                }
            }

            function stopAISimulationText() {
                clearInterval(simulatedProcessingInterval);
                if (domElements.aiProcessingSimulationDiv) {
                    domElements.aiProcessingSimulationDiv.style.display = 'none';
                }
            }

            // Function to populate checkbox pills
            function populateCheckboxPills(container, items, groupName) {
                if (!container) return;
                container.innerHTML = ''; // Clear existing pills
                items.forEach(item => {
                    const pillLabel = document.createElement('label');
                    pillLabel.classList.add('checkbox-pill');
                    const checkbox = document.createElement('input');
                    checkbox.type = 'checkbox';
                    checkbox.name = groupName;
                    checkbox.value = item.value;
                    checkbox.addEventListener('change', function () {
                        pillLabel.classList.toggle('selected', this.checked);
                        initialPreselectionDoneForCurrentImage = true; // User interaction overrides AI preselection
                        if (currentImage && imageAnalysisResults) { // Update prompt if an image is loaded and analyzed
                            updateAIDisplayAndStablePrompt();
                        }
                    });
                    pillLabel.appendChild(checkbox);
                    pillLabel.appendChild(document.createTextNode(item.label));
                    container.appendChild(pillLabel);
                });
            }
            // Populate all cue sections
            populateCheckboxPills(domElements.moodPillsContainer, moodItems, 'mood');
            populateCheckboxPills(domElements.genrePillsContainer, genreItems, 'genre');
            populateCheckboxPills(domElements.instrumentPillsContainer, instrumentItems, 'instrument');
            populateCheckboxPills(domElements.rhythmPillsContainer, rhythmItems, 'rhythm');


            // Helper to get selected checkbox values
            function getSelectedCheckboxValues(groupName) {
                return Array.from(document.querySelectorAll(`input[name="${groupName}"]:checked`)).map(cb => cb.value);
            }
            // Helper to convert RGB to HSL (for color analysis details)
            function rgbToHsl(r, g, b) {
                r /= 255; g /= 255; b /= 255; const max = Math.max(r, g, b), min = Math.min(r, g, b); let h, s, l = (max + min) / 2;
                if (max === min) { h = s = 0; } else {
                    const d = max - min; s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                    switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; } h /= 6;
                }
                return { h: h * 360, s: s * 100, l: l * 100 };
            }
            // Helper to translate object class from English (COCO-SSD) to Italian
            function translateObject(objectClass) {
                return objectTranslations[objectClass.toLowerCase()] || objectClass;
            }
            // Helper to translate emotion from English (FaceAPI) to Italian
            function translateEmotion(emotion) {
                return emotionTranslations[emotion.toLowerCase()] || emotion;
            }
            // Toggle visibility of detection canvas (for debugging)
            function toggleDetectionCanvasVisibility() {
                domElements.detectionCanvas.style.display = showDetections ? 'block' : 'none';
            }

            // Core logic to determine musical cues based on analysis and user input
            function getMusicalCues(analysis, detectedObjects, detectedEmotions, creativityLevel, userInputs) {
                const cues = {
                    moods: [...userInputs.selectedMoods],
                    genres: [...userInputs.selectedGenres],
                    instruments: [...userInputs.selectedInstruments],
                    rhythms: [...userInputs.selectedRhythms],
                    tempoBPM: userInputs.selectedBPM,
                    tempoDescription: userInputs.selectedBPM <= 76 ? "lento" : userInputs.selectedBPM <= 120 ? "moderato" : "veloce",
                    energy: "medium", tonality: "misto", keywords: [], vocalPresence: "strumentale",
                    creativityLevel: creativityLevel
                };

                // Add all user-selected items to keywords initially
                cues.keywords.push(...userInputs.selectedMoods, ...userInputs.selectedGenres, ...userInputs.selectedInstruments, ...userInputs.selectedRhythms);

                // AI-driven suggestions if no user input for a category AND initial preselection hasn't happened
                if (!initialPreselectionDoneForCurrentImage) {
                    let primaryEmotion = detectedEmotions.length > 0 ? detectedEmotions.filter(e => e !== "neutrale")[0] || "neutrale" : "neutrale";

                    // Suggest moods based on detected emotions if user hasn't selected any
                    if (cues.moods.length === 0 && detectedEmotions && detectedEmotions.length > 0) {
                        let significantEmotions = detectedEmotions.filter(e => e !== "neutrale");
                        if (significantEmotions.length === 0 && detectedEmotions.includes("neutrale")) significantEmotions = ["neutrale"]; // Default to neutral if only neutral detected
                        if (significantEmotions.length > 0) {
                            primaryEmotion = significantEmotions[0]; // Use the first significant emotion
                            const aiMoodSuggestions = [];
                            switch (primaryEmotion) {
                                case "felice": aiMoodSuggestions.push("gioioso", "ottimista"); break;
                                case "triste": aiMoodSuggestions.push("malinconico", "riflessivo"); break;
                                case "arrabbiato/a": aiMoodSuggestions.push("intenso", "potente"); break;
                                case "sorpreso/a": aiMoodSuggestions.push("meravigliato", "anticipatorio"); break;
                                case "impaurito/a": aiMoodSuggestions.push("inquietante", "sospeso"); break;
                                default: aiMoodSuggestions.push("atmosferico", "contemplativo"); break;
                            }
                            aiMoodSuggestions.forEach(m => { if (!cues.moods.includes(m)) cues.moods.push(m); });
                        }
                    }
                    // Suggest moods based on image properties (brightness, saturation) if still no moods
                    if (cues.moods.length === 0 && analysis) {
                        if (analysis.averageBrightness < 70) { if (!cues.moods.includes("oscuro")) cues.moods.push("oscuro"); if (!cues.moods.includes("profondo")) cues.moods.push("profondo"); }
                        else if (analysis.averageBrightness > 180) { if (!cues.moods.includes("brillante")) cues.moods.push("brillante"); if (!cues.moods.includes("luminoso")) cues.moods.push("luminoso"); }
                        if (analysis.averageSaturation < 30) { if (!cues.moods.includes("tenue")) cues.moods.push("tenue"); if (!cues.moods.includes("desaturato")) cues.moods.push("desaturato"); }
                        else if (analysis.averageSaturation > 70) { if (!cues.moods.includes("vibrante")) cues.moods.push("vibrante"); if (!cues.moods.includes("saturo")) cues.moods.push("saturo"); }
                    }

                    // Suggest genres based on detected objects if user hasn't selected any
                    if (cues.genres.length === 0 && detectedObjects && detectedObjects.length > 0) {
                        if (detectedObjects.some(o => ["natura", "albero", "montagna", "fiore", "foresta", "lago"].includes(o))) {
                            if (!cues.genres.includes("Folk Acustico")) cues.genres.push("Folk Acustico");
                            if (!cues.genres.includes("Ambient Naturale")) cues.genres.push("Ambient Naturale");
                        }
                        if (detectedObjects.some(o => ["città", "strada", "auto"].includes(o))) {
                            if (!cues.genres.includes("Urban Jazz")) cues.genres.push("Urban Jazz");
                            if (!cues.genres.includes("Lo-fi Hip Hop")) cues.genres.push("Lo-fi Hip Hop");
                        }
                    }
                    // Suggest instruments based on dominant colors if user selected few/none
                    if (cues.instruments.length < 2 && analysis && analysis.dominantColors && analysis.dominantColors.length > 0) {
                        const mainColor = analysis.dominantColors[0]; const H = mainColor.hue; const S = mainColor.saturation; const L = mainColor.lightness;
                        if (L < 40 && S > 30) { if (!cues.instruments.includes("basso profondo")) cues.instruments.push("basso profondo"); if (!cues.instruments.includes("violoncello")) cues.instruments.push("violoncello"); }
                        else if (L > 70 && S > 40) { if (!cues.instruments.includes("flauto brillante")) cues.instruments.push("flauto brillante"); if (!cues.instruments.includes("glockenspiel")) cues.instruments.push("glockenspiel"); }
                        if (S < 25) { if (!cues.instruments.includes("pad eterei")) cues.instruments.push("pad eterei"); if (!cues.instruments.includes("chitarra con riverbero")) cues.instruments.push("chitarra con riverbero"); }
                    }
                } // End of initialPreselectionDoneForCurrentImage block

                // Determine overall energy and tonality based on selected/suggested moods
                const finalMoods = [...new Set(cues.moods)]; // Ensure unique moods
                if (finalMoods.some(m => ["felice", "gioioso", "energico", "ottimista"].includes(m))) {
                    if (cues.energy === "medium") cues.energy = "high";
                    if (cues.tonality === "misto") cues.tonality = "maggiore";
                } else if (finalMoods.some(m => ["triste", "malinconico", "riflessivo", "sospeso"].includes(m))) {
                    if (cues.energy === "medium") cues.energy = "low";
                    if (cues.tonality === "misto") cues.tonality = "minore";
                }

                // Suggest vocal presence if a person is detected and user hasn't specified vocals
                if (detectedObjects.includes("persona") && cues.vocalPresence === "strumentale" && !userInputs.selectedInstruments.some(inst => inst.toLowerCase().includes("voce"))) {
                    cues.vocalPresence = "voce solista"; // Suggest solo voice
                }


                // Consolidate keywords and ensure uniqueness
                cues.keywords.push(...cues.moods, ...cues.genres, ...cues.instruments, ...cues.rhythms, cues.tempoBPM + " BPM");
                cues.keywords = [...new Set(cues.keywords.filter(Boolean))]; // Filter out empty/null and ensure unique

                // Create a user-friendly text representation of selected cues (for display)
                cues.userTextCues = [...new Set(cues.moods)].join(", ") +
                    ([...new Set(cues.genres)].length > 0 ? ", " + [...new Set(cues.genres)].join(", ") : "") +
                    ([...new Set(cues.instruments)].length > 0 ? ", " + [...new Set(cues.instruments)].join(", ") : "") +
                    ([...new Set(cues.rhythms)].length > 0 ? ", Ritmo: " + [...new Set(cues.rhythms)].join(", ") : "");

                // Final cleanup of cue arrays
                cues.moods = [...new Set(cues.moods)];
                cues.genres = [...new Set(cues.genres)];
                cues.instruments = [...new Set(cues.instruments)];
                cues.rhythms = [...new Set(cues.rhythms)];
                if (cues.moods.length === 0) cues.moods.push("descrittivo"); // Default mood if none selected/suggested

                return cues;
            }

            // Generates the HTML content for the AI Insights section
            function generateAIDisplayContent(analysis, detectedObjectsList, detectedEmotionsList, userInputs, finalStablePrompt) {
                const simulationDiv = domElements.aiInsightsContent.querySelector('.ai-processing-simulation');
                // Clear previous analysis details, but keep the simulation div template if it exists
                const existingDetails = domElements.aiInsightsContent.querySelectorAll('h4, ul, #finalPromptForAI');
                existingDetails.forEach(el => {
                    if (!el.classList.contains('ai-processing-simulation')) { // Don't remove the simulation div itself
                        el.remove();
                    }
                });

                if (simulationDiv) simulationDiv.style.display = 'none'; // Hide simulation text area


                // Build HTML for image analysis details
                let analysisContentHTML = "<h4>Analisi Immagine:</h4><ul>";
                analysisContentHTML += `<li><strong>Oggetti Rilevati:</strong> ${detectedObjectsList && detectedObjectsList.length > 0 ? detectedObjectsList.join(", ") : "Nessuno o non significativi"}</li>`;
                analysisContentHTML += `<li><strong>Emozioni Percepite:</strong> ${detectedEmotionsList && detectedEmotionsList.length > 0 && detectedEmotionsList.some(e => e !== "neutrale" || detectedEmotionsList.length === 1) ? detectedEmotionsList.join(", ") : "Nessuna o non significativa"}</li>`;
                if (analysis) { // analysis here refers to imageAnalysisResults.colors
                    let brightnessDesc = "Media"; if (analysis.averageBrightness < 80) brightnessDesc = "Bassa (scena tendenzialmente scura)"; else if (analysis.averageBrightness > 170) brightnessDesc = "Alta (scena molto luminosa)"; analysisContentHTML += `<li><strong>Luminosità Generale:</strong> ${brightnessDesc}</li>`;
                    let contrastDesc = "Medio"; if (analysis.contrast < 30) contrastDesc = "Basso (immagine morbida, poco stacco)"; else if (analysis.contrast > 70) contrastDesc = "Alto (forte stacco tra chiari e scuri)"; analysisContentHTML += `<li><strong>Contrasto:</strong> ${contrastDesc}</li>`;
                    let saturationDesc = "Media"; if (analysis.averageSaturation < 30) saturationDesc = "Bassa (colori tenui, desaturati)"; else if (analysis.averageSaturation > 70) saturationDesc = "Alta (colori vividi e saturi)"; analysisContentHTML += `<li><strong>Saturazione Colori:</strong> ${saturationDesc}</li>`;
                    if (analysis.dominantColors && analysis.dominantColors.length > 0) {
                        analysisContentHTML += "<li><strong>Colori Dominanti:</strong><ul>";
                        analysis.dominantColors.forEach(c => { analysisContentHTML += `<li><span class="color-swatch-inline" style="background-color: rgb(${c.r},${c.g},${c.b});"></span>rgb(${c.r},${c.g},${c.b}) - ${c.percentage.toFixed(0)}% (H:${c.hue.toFixed(0)} S:${c.saturation.toFixed(0)} L:${c.lightness.toFixed(0)}) ~${c.pixelCount}px</li>`; });
                        analysisContentHTML += "</ul></li>";
                    }
                }
                analysisContentHTML += "</ul>";

                // Get the final musical cues based on current state for display
                const displayCues = getMusicalCues(analysis, detectedObjectsList, detectedEmotionsList, CREATIVITY_LEVEL, userInputs);

                // Build HTML for musical interpretation
                let interpretationHtml = "<h4>Interpretazione Musicale Suggerita (basata sull'analisi e tue scelte):</h4><ul>";
                if (displayCues.moods.length > 0) interpretationHtml += `<li><strong>Mood:</strong> ${displayCues.moods.join(", ")}</li>`;
                if (displayCues.genres.length > 0) interpretationHtml += `<li><strong>Generi:</strong> ${displayCues.genres.join(", ")}</li>`;
                if (displayCues.instruments.length > 0) interpretationHtml += `<li><strong>Strumenti:</strong> ${displayCues.instruments.join(", ")}</li>`;
                if (displayCues.rhythms.length > 0) interpretationHtml += `<li><strong>Ritmo:</strong> ${displayCues.rhythms.map(r => rhythmItems.find(i => i.value === r)?.label || r).join(", ")}</li>`; // Show label for rhythm
                interpretationHtml += `<li><strong>Energia:</strong> ${displayCues.energy}</li>`;
                interpretationHtml += `<li><strong>Tempo:</strong> ${displayCues.tempoDescription} (${displayCues.tempoBPM} BPM)</li>`;
                if (displayCues.tonality !== "misto") interpretationHtml += `<li><strong>Tonalità:</strong> ${displayCues.tonality}</li>`;
                interpretationHtml += `<li><strong>Presenza Vocale:</strong> ${displayCues.vocalPresence}</li>`;
                interpretationHtml += "</ul>";
                interpretationHtml += `<div id="finalPromptForAI">${finalStablePrompt}</div>`; // Display the final English prompt

                // Insert the generated HTML into the AI Insights content area
                if (domElements.aiProcessingSimulationDiv) { // If simulation div exists, insert after it
                    domElements.aiProcessingSimulationDiv.insertAdjacentHTML('afterend', analysisContentHTML + interpretationHtml);
                } else { // Otherwise, append to the main content div
                    domElements.aiInsightsContent.innerHTML += analysisContentHTML + interpretationHtml;
                }
            }

            // Generates the final English prompt for the music generation API
            function generateStableAudioPrompt(parsedData) {
                if (!parsedData) return "Data analysis not available.";
                let p = []; // Array to build prompt parts
                const creativity = parsedData.creativityLevel || 50; // Use creativity level from parsedData

                // Translate user/AI selected cues to English
                let moodsEN = parsedData.moods.map(m => translateCueToEnglish(m, 'mood')).filter(Boolean);
                let genresEN = parsedData.genres.map(g => translateCueToEnglish(g, 'genre')).filter(Boolean);
                let instrumentsEN = parsedData.instruments.map(i => translateCueToEnglish(i, 'instrument')).filter(Boolean);
                let rhythmsEN = parsedData.rhythms.map(r => translateCueToEnglish(r, 'rhythm')).filter(Boolean);

                // Main description: combination of moods and genres
                let mainDescriptionParts = [...new Set([...moodsEN, ...genresEN])]; // Unique combination
                if (mainDescriptionParts.length > 0) {
                    p.push(mainDescriptionParts.slice(0, creativity > 60 ? 4 : 3).join(", ")); // Limit number of main descriptors
                } else {
                    p.push("evocative soundscape"); // Default if no strong descriptors
                }

                // Add cues based on image color analysis (if available)
                if (imageAnalysisResults && imageAnalysisResults.colors) {
                    const { averageBrightness, averageSaturation, contrast, dominantColors } = imageAnalysisResults.colors;
                    if (averageBrightness < 80 && !p.includes("dark atmosphere")) p.push("dark atmosphere");
                    else if (averageBrightness > 170 && !p.includes("bright") && !p.includes("luminous")) p.push("bright", "luminous");

                    if (contrast < 30 && !p.includes("smooth texture")) p.push("smooth texture");
                    else if (contrast > 70 && !p.includes("high contrast sound")) p.push("high contrast sound");

                    if (averageSaturation < 30 && !p.includes("muted tones") && !p.includes("desaturated feel")) p.push("muted tones", "desaturated feel");
                    else if (averageSaturation > 70 && !p.includes("vibrant colors") && !p.includes("rich sound")) p.push("vibrant colors", "rich sound");

                    if (dominantColors && dominantColors.length > 0) {
                        const H = dominantColors[0].hue; // Use hue of the most dominant color
                        if ((H >= 0 && H < 60 || H >= 330) && !p.includes("warm color palette")) p.push("warm color palette"); // Reds, Oranges, Yellows
                        else if (H >= 120 && H < 270 && !p.includes("cool color palette")) p.push("cool color palette"); // Greens, Blues, Purples
                    }
                }

                // Add rhythm cues
                if (rhythmsEN.length > 0) {
                    if (rhythmsEN.includes("no distinct rhythm")) { // Special handling for ambient
                        if (!p.some(term => term.includes("ambient"))) p.push("ambient");
                        if (!p.some(term => term.includes("atmospheric"))) p.push("atmospheric");
                    } else {
                        p.push(...[...new Set(rhythmsEN)]); // Add other rhythm descriptions
                    }
                }

                // Add BPM, energy, and tonality
                p.push(parsedData.tempoBPM + " BPM");
                let energyEN = translateCueToEnglish(parsedData.energy, 'general'); // Assuming energy is a general term like "low", "medium", "high"
                if (energyEN && !p.some(term => term.includes(energyEN))) p.push(energyEN + " energy");

                if (parsedData.tonality && parsedData.tonality.toLowerCase() !== "misto") {
                    let tonalityEN = translateCueToEnglish(parsedData.tonality, 'tonality');
                    if (tonalityEN && !p.some(term => term.includes(tonalityEN))) p.push(tonalityEN + " tonality");
                }

                // Add instruments, limiting the number
                if (instrumentsEN.length > 0) {
                    const uniqueInstruments = [...new Set(instrumentsEN)].filter(i => i.trim() !== ""); // Remove empty strings
                    if (uniqueInstruments.length > 0) {
                        p.push("featuring " + uniqueInstruments.slice(0, creativity > 60 ? 4 : 3).join(", "));
                    }
                }

                // Add keywords from detected objects (if any, and not already covered)
                let additionalKeywordsEN = [];
                if (imageAnalysisResults && imageAnalysisResults.objects && imageAnalysisResults.objects.length > 0) {
                    const translatedObjectsForPrompt = imageAnalysisResults.objects
                        .map(objIT => translateCueToEnglish(objIT, 'object')) // Translate Italian object names to English
                        .filter(Boolean); // Remove any null/empty results

                    // Filter keywords to avoid redundancy with main description or existing prompt parts
                    const filteredKeywords = translatedObjectsForPrompt.filter(k =>
                        k.length > 2 && // Only consider reasonably long keywords
                        !mainDescriptionParts.some(mainPart => mainPart.toLowerCase().includes(k.toLowerCase())) &&
                        !p.some(promptPart => promptPart.toLowerCase().includes(k.toLowerCase()))
                    );
                    additionalKeywordsEN.push(...[...new Set(filteredKeywords)].slice(0, 2)); // Add a few unique object keywords
                }
                if (additionalKeywordsEN.length > 0) {
                    p.push("with elements of " + additionalKeywordsEN.join(", "));
                }

                // Add vocal presence
                if (parsedData.vocalPresence) {
                    let vocalPresenceEN = "";
                    const lowerVocalPresence = parsedData.vocalPresence.toLowerCase();
                    if (lowerVocalPresence.includes("strumentale")) {
                        vocalPresenceEN = "instrumental, no vocals";
                    } else if (lowerVocalPresence.includes("voce solista")) {
                        vocalPresenceEN = "solo voice";
                    } else { // For other vocal descriptions like "cori"
                        let translatedVocal = translateCueToEnglish(parsedData.vocalPresence, 'instrument'); // Try to translate it as an "instrument"
                        if (translatedVocal && translatedVocal.toLowerCase() !== lowerVocalPresence) { // If translation is different, use it
                            vocalPresenceEN = translatedVocal;
                        } else {
                            vocalPresenceEN = "vocal presence"; // Generic fallback
                        }
                    }
                    if (vocalPresenceEN && !p.includes(vocalPresenceEN) && !(vocalPresenceEN === "instrumental, no vocals" && p.includes("instrumental"))) {
                        p.push(vocalPresenceEN);
                    }
                }

                // Add quality descriptors
                p.push("high quality audio", "clear mix", "professionally mastered");
                if (creativity > 70) p.push("unique sound design", "experimental"); // More creative for higher levels

                // Join all parts, ensure uniqueness, and format
                let finalPrompt = [...new Set(p.map(s => String(s).trim().toLowerCase()).filter(s => s))].join(", ");
                return finalPrompt.charAt(0).toUpperCase() + finalPrompt.slice(1); // Capitalize first letter
            }


            // UI Update Functions
            function setStatusMessage(element, message, type = "info") {
                if (!element) { console.warn("setStatusMessage: elemento non trovato per messaggio:", message); return; }
                element.textContent = message; element.className = 'status-message'; // Reset classes
                if (type === "error") element.classList.add("status-error");
                else if (type === "success") element.classList.add("status-success");
                element.style.display = message ? 'block' : 'none';
                // Explicitly hide if message is empty, unless it's an error/success that should persist briefly
                if (!message && type === "info") { // Only hide info messages when empty
                    element.style.display = 'none';
                }
            }
            function updateProgressMessage(message, isLoading = false) {
                domElements.dynamicFeedbackArea.style.display = 'block'; // Ensure feedback area is visible
                if (!message && !isLoading) { // If no message and not loading, hide progress container
                    domElements.progressAndPlayerContainer.style.display = 'none';
                    domElements.progressMessage.textContent = '';
                    domElements.progressBarContainer.style.display = 'none';
                    return;
                }
                domElements.progressAndPlayerContainer.style.display = 'block'; // Show container
                domElements.progressMessage.textContent = message;
                domElements.progressBarContainer.style.display = isLoading ? 'block' : 'none';
                if (isLoading || message) { // If loading or has a message, hide audio player initially
                    domElements.audioPlayerContainer.style.display = 'none';
                }
            }

            // Load AI Models (TensorFlow.js)
            async function loadModels() {
                console.log("LOG: Inizio caricamento modelli AI...");
                const MODEL_URL = 'https://justadudewhohacks.github.io/face-api.js/models'; // Standard URL for face-api models
                let faceApiReady = false, cocoReady = false;
                setStatusMessage(domElements.statusDiv, "Caricamento modelli AI (Oggetti e Volti)...", "info");
                domElements.dynamicFeedbackArea.style.display = 'block'; // Show feedback area

                try { // Load FaceAPI models
                    if (typeof faceapi !== 'undefined') {
                        await Promise.all([
                            faceapi.nets.tinyFaceDetector.loadFromUri(MODEL_URL),
                            faceapi.nets.faceLandmark68Net.loadFromUri(MODEL_URL),
                            faceapi.nets.faceExpressionNet.loadFromUri(MODEL_URL)
                        ]);
                        faceApiModelLoaded = true; faceApiReady = true;
                        console.log("LOG: Modelli face-api.js caricati.");
                    } else {
                        console.error("ERRORE CRITICO: Libreria face-api.js non trovata. Assicurati che 'js/face-api.min.js' sia caricato.");
                    }
                } catch (error) { console.error("ERRORE caricamento face-api:", error); }

                try { // Load COCO-SSD model
                    if (typeof cocoSsd !== 'undefined') {
                        cocoSsdModel = await cocoSsd.load();
                        cocoReady = true;
                        console.log("LOG: Modello COCO-SSD caricato.");
                    } else {
                        console.error("ERRORE CRITICO: Libreria COCO-SSD non trovata. Assicurati che 'js/coco-ssd.min.js' sia caricato.");
                    }
                } catch (error) { console.error("ERRORE caricamento COCO-SSD:", error); }

                if (faceApiReady && cocoReady) {
                    setStatusMessage(domElements.statusDiv, "Tutti i modelli AI pronti. Carica un'immagine.", "success");
                    console.log("LOG: Tutti i modelli AI caricati con successo.");
                } else {
                    let failedModels = [];
                    if (!cocoReady) failedModels.push("Rilevamento Oggetti");
                    if (!faceApiReady) failedModels.push("Rilevamento Volti");
                    setStatusMessage(domElements.statusDiv, `ATTENZIONE: Caricamento fallito per: ${failedModels.join(" e ")}. Funzionalità limitate.`, "error");
                    console.error("ERRORE: Caricamento fallito per:", failedModels.join(" e "));
                }
                // Hide status if no other message is in progress and audio is not playing
                if (domElements.statusDiv.textContent === "Tutti i modelli AI pronti. Carica un'immagine." && !domElements.progressMessage.textContent && domElements.audioPlayerContainer.style.display === 'none') {
                    setTimeout(() => { // Hide after a short delay
                        if (domElements.statusDiv.textContent === "Tutti i modelli AI pronti. Carica un'immagine.") { // Check again before hiding
                            domElements.statusDiv.style.display = 'none';
                            domElements.dynamicFeedbackArea.style.display = 'none';
                        }
                    }, 3000);
                }
            }
            // Image Analysis Functions
            function analyzeImageAdvanced(imageElement, numDominantColors = 5) {
                if (!imageElement || !imageElement.complete || imageElement.naturalHeight === 0) {
                    console.warn("WARN: analyzeImageAdvanced - Immagine non valida o non caricata.");
                    return null; // Return null or a default structure
                }
                // Downscale image for faster processing on a temporary canvas
                const aspectRatio = imageElement.naturalWidth / imageElement.naturalHeight; const canvasWidth = 120; /* Smaller canvas for analysis */ const canvasHeight = Math.round(canvasWidth / aspectRatio);
                domElements.imageCanvas.width = canvasWidth; domElements.imageCanvas.height = canvasHeight; imageAnalysisCtx.drawImage(imageElement, 0, 0, canvasWidth, canvasHeight);
                const imageData = imageAnalysisCtx.getImageData(0, 0, canvasWidth, canvasHeight); const pixels = imageData.data; const colorCounts = {}; let totalBrightnessSum = 0; let totalAnalyzedPixels = 0;
                const colorDepthReduction = 4; // 2^4 = 16 bins per channel (0-15), so 16*16*16 = 4096 possible colors
                const binSize = Math.pow(2, 8 - colorDepthReduction); // e.g., 256 / 16 = 16

                for (let i = 0; i < pixels.length; i += 4) { // Iterate through pixels (RGBA)
                    const r_orig = pixels[i], g_orig = pixels[i + 1], b_orig = pixels[i + 2], alpha = pixels[i + 3];
                    if (alpha > 128) { // Consider only opaque pixels
                        const r_binned = Math.floor(r_orig / binSize) * binSize; // Bin colors to reduce granularity
                        const g_binned = Math.floor(g_orig / binSize) * binSize;
                        const b_binned = Math.floor(b_orig / binSize) * binSize;
                        const colorKey = `${r_binned},${g_binned},${b_binned}`;
                        colorCounts[colorKey] = (colorCounts[colorKey] || 0) + 1;
                        totalBrightnessSum += (r_orig + g_orig + b_orig) / 3; // Sum brightness (simple average)
                        totalAnalyzedPixels++;
                    }
                }
                if (totalAnalyzedPixels === 0) return { dominantColors: [], averageBrightness: 128, contrast: 0, averageSaturation: 50 }; // Default if no pixels analyzed

                const sortedColors = Object.entries(colorCounts).sort(([, a], [, b]) => b - a).slice(0, numDominantColors).map(([k, count]) => {
                    const [r, g, b] = k.split(',').map(Number); const hsl = rgbToHsl(r, g, b);
                    return { r, g, b, percentage: (count / totalAnalyzedPixels) * 100, hue: hsl.h, saturation: hsl.s, lightness: hsl.l, pixelCount: count };
                });
                const avgB = totalBrightnessSum / totalAnalyzedPixels; let minL = 100, maxL = 0, totS = 0;
                sortedColors.forEach(c => { minL = Math.min(minL, c.lightness); maxL = Math.max(maxL, c.lightness); totS += c.saturation; });
                return { dominantColors: sortedColors, averageBrightness: avgB, contrast: (maxL - minL), averageSaturation: sortedColors.length > 0 ? totS / sortedColors.length : 50 };
            }
            async function detectObjectsInImage(imageElementForDetection) {
                if (!cocoSsdModel) { console.warn("WARN: Modello COCO-SSD non pronto per rilevamento oggetti."); return []; }
                try {
                    const predictions = await cocoSsdModel.detect(imageElementForDetection);
                    const filtered = predictions.filter(p => p.score > 0.55); // Filter by confidence score
                    console.log("LOG: Oggetti rilevati (originale EN):", filtered.map(p => p.class));
                    return filtered.map(p => translateObject(p.class)); // Translate to Italian for display
                } catch (e) {
                    console.error("ERRORE COCO-SSD:", e); return [];
                }
            }
            async function analyzeFacesInImage(imageElementForDetection) {
                if (!faceApiModelLoaded) { console.warn("WARN: Modello FaceAPI non pronto per analisi volti."); return []; }
                try {
                    const detections = await faceapi.detectAllFaces(imageElementForDetection, new faceapi.TinyFaceDetectorOptions()).withFaceLandmarks().withFaceExpressions();
                    return detections.map(d => {
                        let dominantEmotionKey = "neutral"; // Default emotion
                        if (d.expressions && Object.keys(d.expressions).length > 0) {
                            dominantEmotionKey = Object.keys(d.expressions).reduce((a, b) => d.expressions[a] > d.expressions[b] ? a : b);
                        }
                        return translateEmotion(dominantEmotionKey); // Translate to Italian for display
                    });
                } catch (e) {
                    console.error("ERRORE FaceAPI:", e); return [];
                }
            }

            // QR Code and Composite Image Functions
            async function generateQrCodeToCanvas(canvasElement, text, size = 120) {
                console.log(`LOG DEBUG QR: Chiamata a generateQrCodeToCanvas con testo: "${text}", dimensione: ${size}`);
                return new Promise((resolve, reject) => {
                    if (typeof QRCode === 'undefined') {
                        console.error("ERRORE CRITICO: Libreria QRCode non è definita! Assicurati che 'js/qrcode.min.js' sia caricato.");
                        return reject(new Error("Libreria QRCode non definita"));
                    }
                    if (typeof QRCode.toCanvas !== 'function') {
                        console.error("ERRORE CRITICO: QRCode.toCanvas non è una funzione! La libreria potrebbe essere errata o non caricata.");
                        return reject(new TypeError("QRCode.toCanvas is not a function"));
                    }

                    const options = {
                        width: size,
                        margin: 1, // Small margin around QR
                        errorCorrectionLevel: 'H' // High error correction
                    };
                    QRCode.toCanvas(canvasElement, text, options, function (error) {
                        if (error) {
                            console.error("ERRORE DEBUG QR: Errore generazione QR Code:", error);
                            reject(error);
                        } else {
                            console.log(`LOG DEBUG QR: QR Code generato su canvas (${canvasElement.width}x${canvasElement.height}) per:`, text);
                            resolve(canvasElement);
                        }
                    });
                });
            }

            async function createCompositeImage(originalImageElement, qrCodeCanvasElement, targetCanvasElement) {
                console.log("LOG DEBUG QR: Inizio createCompositeImage.");
                const ctx = targetCanvasElement.getContext('2d');
                const PADDING_FACTOR = 0.03; // Padding relative to image width for QR code placement

                // Calculate padding based on original image width
                const PADDING = originalImageElement.naturalWidth * PADDING_FACTOR;

                // Use the actual dimensions of the QR code canvas for drawing
                const QR_DRAW_WIDTH = qrCodeCanvasElement.width;
                const QR_DRAW_HEIGHT = qrCodeCanvasElement.height;
                console.log(`LOG DEBUG QR: Dimensioni QR canvas per disegno: ${QR_DRAW_WIDTH}x${QR_DRAW_HEIGHT}`);


                // Set composite canvas dimensions to original image dimensions
                targetCanvasElement.width = originalImageElement.naturalWidth;
                targetCanvasElement.height = originalImageElement.naturalHeight;
                console.log(`LOG DEBUG QR: Dimensioni canvas composito: ${targetCanvasElement.width}x${targetCanvasElement.height}`);


                // Draw the original image
                ctx.drawImage(originalImageElement, 0, 0);
                console.log("LOG DEBUG QR: Immagine originale disegnata su canvas composito.");

                // Calculate QR code position (bottom-right corner with padding)
                const qrX = targetCanvasElement.width - QR_DRAW_WIDTH - PADDING;
                const qrY = targetCanvasElement.height - QR_DRAW_HEIGHT - PADDING;
                console.log(`LOG DEBUG QR: Posizione QR (X,Y): ${qrX}, ${qrY}`);

                // Draw a semi-transparent background for the QR code for better visibility
                ctx.fillStyle = 'rgba(255, 255, 255, 0.85)'; // White with some transparency
                ctx.fillRect(qrX - PADDING / 2, qrY - PADDING / 2, QR_DRAW_WIDTH + PADDING, QR_DRAW_HEIGHT + PADDING); // Background slightly larger than QR

                // Optional: add a border around the QR code background
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
                ctx.lineWidth = 1;
                ctx.strokeRect(qrX - PADDING / 2, qrY - PADDING / 2, QR_DRAW_WIDTH + PADDING, QR_DRAW_HEIGHT + PADDING);
                console.log("LOG DEBUG QR: Sfondo e bordo per QR disegnati.");

                // Draw the QR code itself
                ctx.drawImage(qrCodeCanvasElement, qrX, qrY, QR_DRAW_WIDTH, QR_DRAW_HEIGHT);
                console.log("LOG DEBUG QR: Canvas QR disegnato su canvas composito.");

                const dataUrl = targetCanvasElement.toDataURL('image/png'); // Get Data URL of the composite image
                console.log("LOG DEBUG QR: Immagine composita creata come Data URL.");
                return dataUrl;
            }

            // Preselects cue checkboxes based on AI analysis (only if user hasn't interacted yet)
            function preselectCuesFromAnalysis(musicalCues) {
                if (!musicalCues) return;

                const preselectGroup = (groupItems, cueValues, groupName) => {
                    groupItems.forEach(item => {
                        const checkbox = document.querySelector(`input[name="${groupName}"][value="${item.value}"]`);
                        if (checkbox) {
                            const pillLabel = checkbox.closest('.checkbox-pill');
                            if (cueValues.map(cv => cv.toLowerCase()).includes(item.value.toLowerCase())) {
                                checkbox.checked = true;
                                pillLabel.classList.add('selected');
                            } else {
                                checkbox.checked = false; // Ensure others are deselected if not in AI cues
                                pillLabel.classList.remove('selected');
                            }
                        }
                    });
                };

                preselectGroup(moodItems, musicalCues.moods || [], 'mood');
                preselectGroup(genreItems, musicalCues.genres || [], 'genre');
                preselectGroup(instrumentItems, musicalCues.instruments || [], 'instrument');
                preselectGroup(rhythmItems, musicalCues.rhythms || [], 'rhythm');

                // Automatically open sections that have preselected cues
                document.querySelectorAll('.cues-selection-container').forEach(container => {
                    const header = container.querySelector('label.group-label.collapsible-cue-header');
                    const pillsGroup = container.querySelector('.checkbox-pills-group');
                    if (header && pillsGroup) {
                        const hasSelectedPill = Array.from(pillsGroup.querySelectorAll('.checkbox-pill.selected')).length > 0;
                        if (hasSelectedPill && !header.classList.contains('open')) {
                            header.classList.add('open');
                            pillsGroup.classList.add('open');
                            const bpmSliderContainer = header.parentElement.querySelector('.bpm-slider-container');
                            if (bpmSliderContainer) { // Show BPM slider if its mood section is opened
                                bpmSliderContainer.style.display = 'block';
                            }
                        }
                    }
                });
            }


            // Main function to update AI display and the stable audio prompt
            async function updateAIDisplayAndStablePrompt() {
                if (!currentImage) { console.warn("WARN: updateAIDisplayAndStablePrompt chiamato senza currentImage."); return; }

                // Perform analysis if not already done for the current image
                if (!imageAnalysisResults) {
                    domElements.dynamicFeedbackArea.style.display = 'block';
                    domElements.statusDiv.classList.add('hidden'); // Hide general status if specific progress is shown
                    updateProgressMessage("Analisi immagine in corso...", true); // Show progress bar
                    startAISimulationText(); // Start text animation in AI insights

                    imageAnalysisResults = {
                        colors: analyzeImageAdvanced(currentImage),
                        objects: await detectObjectsInImage(currentImage),
                        emotions: await analyzeFacesInImage(currentImage)
                    };
                    stopAISimulationText(); // Stop text animation
                    initialPreselectionDoneForCurrentImage = false; // Reset flag for new image analysis
                }

                // Get current user selections from checkboxes and BPM slider
                const selectedMoods = getSelectedCheckboxValues('mood');
                const selectedGenres = getSelectedCheckboxValues('genre');
                const selectedInstruments = getSelectedCheckboxValues('instrument');
                const selectedRhythms = getSelectedCheckboxValues('rhythm');
                const selectedBPM = domElements.bpmSlider.value;
                const userInputs = { selectedMoods, selectedGenres, selectedInstruments, selectedRhythms, selectedBPM };

                // Get musical cues based on analysis and user inputs
                const tempParsedCues = getMusicalCues(imageAnalysisResults.colors, imageAnalysisResults.objects, imageAnalysisResults.emotions, CREATIVITY_LEVEL, userInputs);

                // If AI preselection hasn't been done (or overridden by user), do it now
                if (!initialPreselectionDoneForCurrentImage) {
                    preselectCuesFromAnalysis(tempParsedCues);
                    initialPreselectionDoneForCurrentImage = true; // Mark as done
                }

                // Generate the final English prompt for the music API
                stableAudioPromptForMusic = generateStableAudioPrompt(tempParsedCues);

                // Update the AI Insights display section
                generateAIDisplayContent(imageAnalysisResults.colors, imageAnalysisResults.objects, imageAnalysisResults.emotions, userInputs, stableAudioPromptForMusic);
                domElements.aiInsightsSection.style.display = 'block'; // Show the AI insights section

                // Flash accordion header if it's closed but has new content
                if (imageAnalysisResults && !domElements.detailsAccordionHeader.classList.contains('open') && domElements.aiInsightsContent.innerHTML.includes('<h4>')) {
                    domElements.detailsAccordionHeader.classList.add('new-content-flash');
                    setTimeout(() => { domElements.detailsAccordionHeader.classList.remove('new-content-flash'); }, 1800); // Remove flash after animation
                }
                console.log("LOG: Prompt per Stability AI (Inglese):", stableAudioPromptForMusic);
                // Enable or disable the generate music button based on prompt validity
                if (stableAudioPromptForMusic && !stableAudioPromptForMusic.toLowerCase().includes("errore") && !stableAudioPromptForMusic.toLowerCase().includes("data analysis not available")) {
                    domElements.generateMusicButton.disabled = false;
                } else {
                    domElements.generateMusicButton.disabled = true;
                }
            }

            // Process new image (from upload or camera)
            function processImage(imageSrc) {
                console.log("LOG: Inizio processImage con src:", imageSrc ? "presente" : "mancante");
                domElements.imagePreview.src = imageSrc;
                currentImageSrc = imageSrc; // Store for fullscreen view
                domElements.imagePreview.style.display = 'block';
                imageAnalysisResults = null; // Reset analysis results for new image
                initialPreselectionDoneForCurrentImage = false; // Reset preselection flag


                currentImage = new Image(); // Create a new Image object
                currentImage.onload = async () => {
                    console.log("LOG: currentImage caricata. Dimensioni:", currentImage.naturalWidth, "x", currentImage.naturalHeight);
                    // Set detection canvas size to match preview image size for accurate overlay
                    domElements.detectionCanvas.width = domElements.imagePreview.clientWidth;
                    domElements.detectionCanvas.height = domElements.imagePreview.clientHeight;
                    detectionCtx.clearRect(0, 0, domElements.detectionCanvas.width, domElements.detectionCanvas.height); // Clear previous detections
                    toggleDetectionCanvasVisibility(); // Show/hide based on showDetections flag

                    // Reset UI for new analysis
                    domElements.generateMusicButton.disabled = true; // Disable button until analysis is complete
                    setStatusMessage(domElements.statusDiv, "Immagine caricata. Analisi in corso...", "info");
                    domElements.dynamicFeedbackArea.style.display = 'block'; // Show feedback area
                    updateProgressMessage("Analisi immagine in corso...", true); // Show progress bar
                    stableAudioPromptForMusic = ""; // Clear previous prompt

                    // Hide AI insights and clear old content
                    domElements.aiInsightsSection.style.display = 'none';
                    if (domElements.detailsAccordionHeader) domElements.detailsAccordionHeader.classList.remove('open');
                    if (domElements.aiInsightsContent) {
                        domElements.aiInsightsContent.style.display = 'none';
                        const simDiv = domElements.aiInsightsContent.querySelector('.ai-processing-simulation');
                        const existingDetails = domElements.aiInsightsContent.querySelectorAll('h4, ul, #finalPromptForAI');
                        existingDetails.forEach(el => {
                            if (!el.classList.contains('ai-processing-simulation')) el.remove();
                        });
                        if (simDiv) simDiv.innerHTML = '<p>In attesa di analisi immagine...</p>'; // Reset simulation text
                    }


                    // Hide player and download links
                    domElements.progressAndPlayerContainer.style.display = 'none'; // Initially hide progress/player for new image
                    domElements.audioPlayerContainer.style.display = 'none';
                    domElements.downloadAudioLink.style.display = 'none';
                    domElements.downloadCompositeImageLink.style.display = 'none';
                    domElements.downloadQrOnlyLink.style.display = 'none';

                    // Clear all selected cue pills and close cue sections
                    document.querySelectorAll('.checkbox-pill input[type="checkbox"]:checked').forEach(cb => {
                        cb.checked = false;
                        cb.closest('.checkbox-pill').classList.remove('selected');
                    });
                    document.querySelectorAll('.cues-selection-container label.group-label.open').forEach(header => {
                        header.classList.remove('open');
                        const content = header.nextElementSibling;
                        if (content && content.classList.contains('checkbox-pills-group')) {
                            content.classList.remove('open');
                        }
                        const bpmSliderContainer = header.parentElement.querySelector('.bpm-slider-container');
                        if (bpmSliderContainer) bpmSliderContainer.style.display = 'none'; // Hide BPM slider
                    });
                    domElements.bpmSlider.value = 120; // Reset BPM slider
                    domElements.bpmValueDisplay.textContent = domElements.bpmSlider.value;


                    // Start the analysis and update UI
                    await updateAIDisplayAndStablePrompt();

                    // Update UI after analysis is complete
                    updateProgressMessage("", false); // Hide progress bar
                    domElements.dynamicFeedbackArea.style.display = 'none'; // Hide feedback area if only status was shown
                    setStatusMessage(domElements.statusDiv, "Analisi completata. Scegli spunti o genera direttamente!", "success");
                };
                currentImage.onerror = () => {
                    console.error("ERRORE: Errore durante il caricamento di currentImage.");
                    setStatusMessage(domElements.statusDiv, "Errore caricamento immagine.", "error");
                    updateProgressMessage("Errore caricamento immagine.", false);
                    domElements.generateMusicButton.disabled = true; // Keep button disabled
                };
                currentImage.src = imageSrc; // Set src to trigger onload
            }

            // Initial model loading
            loadModels();

            // Function to start and manage camera stream
            async function startCamera(requestedFacingMode) {
                domElements.imagePreview.style.display = 'none';
                domElements.imagePreview.src = '#';
                currentImage = null;
                imageAnalysisResults = null;
                domElements.aiInsightsSection.style.display = 'none';
                domElements.cameraViewContainer.style.display = 'block';
                domElements.generateMusicButton.disabled = true; // Disable generate button while camera is active

                if (currentStream) { // Stop any existing stream
                    currentStream.getTracks().forEach(track => track.stop());
                }

                let streamAcquired = false;
                const primaryAttemptConstraints = { video: { facingMode: requestedFacingMode }, audio: false };
                const alternateFacingMode = requestedFacingMode === "environment" ? "user" : "environment";
                const alternateAttemptConstraints = { video: { facingMode: alternateFacingMode }, audio: false };
                const genericAttemptConstraints = { video: true, audio: false };

                try {
                    console.log(`Tentativo primario con facingMode: ${requestedFacingMode}`);
                    currentStream = await navigator.mediaDevices.getUserMedia(primaryAttemptConstraints);
                    setStatusMessage(domElements.statusDiv, `Fotocamera (${requestedFacingMode === 'environment' ? 'posteriore' : 'frontale'}) attivata.`, "info");
                    currentFacingMode = requestedFacingMode; // Update global state on success
                    streamAcquired = true;
                } catch (errPrimary) {
                    console.warn(`Errore con facingMode primario (${requestedFacingMode}): ${errPrimary.name} - ${errPrimary.message}`);
                    try {
                        console.log(`Tentativo alternativo con facingMode: ${alternateFacingMode}`);
                        currentStream = await navigator.mediaDevices.getUserMedia(alternateAttemptConstraints);
                        setStatusMessage(domElements.statusDiv, `Fotocamera (${alternateFacingMode === 'environment' ? 'posteriore' : 'frontale'}) attivata (fallback).`, "info");
                        currentFacingMode = alternateFacingMode; // Update global state on success
                        streamAcquired = true;
                    } catch (errAlternate) {
                        console.warn(`Errore con facingMode alternativo (${alternateFacingMode}): ${errAlternate.name} - ${errAlternate.message}`);
                        try {
                            console.log("Tentativo generico (video: true)...");
                            currentStream = await navigator.mediaDevices.getUserMedia(genericAttemptConstraints);
                            const settings = currentStream.getVideoTracks()[0].getSettings();
                            const actualFacingMode = settings.facingMode || "sconosciuto";
                            // If generic attempt, try to infer actual mode, or keep the last intended one
                            currentFacingMode = (actualFacingMode && actualFacingMode !== "unknown") ? actualFacingMode : currentFacingMode;
                            setStatusMessage(domElements.statusDiv, `Fotocamera generica (${currentFacingMode}) attivata (fallback).`, "info");
                            streamAcquired = true;
                        } catch (errGeneric) {
                            console.error("Errore con fotocamera generica:", errGeneric);
                            setStatusMessage(domElements.statusDiv, "Impossibile accedere alla fotocamera. Controlla i permessi.", "error");
                            domElements.cameraViewContainer.style.display = 'none';
                            currentFacingMode = "environment"; // Reset to default if all fail
                        }
                    }
                }

                if (streamAcquired && currentStream) {
                    domElements.cameraFeed.srcObject = currentStream;
                    console.log("Stream fotocamera acquisito e assegnato.");
                } else {
                    console.log("Impossibile acquisire stream fotocamera dopo tutti i tentativi.");
                    domElements.cameraViewContainer.style.display = 'none'; // Hide camera view if no stream
                }
            }


            // Event Listeners
            domElements.imageUpload.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        processImage(e.target.result);
                        domElements.cameraViewContainer.style.display = 'none';
                        if (currentStream) { currentStream.getTracks().forEach(track => track.stop()); currentStream = null; }
                    }
                    reader.readAsDataURL(file);
                }
            });

            domElements.takePictureButton.addEventListener('click', async () => {
                await startCamera(currentFacingMode); // Start with current/default mode
            });

            if (domElements.switchCameraButton) {
                domElements.switchCameraButton.addEventListener('click', async () => {
                    currentFacingMode = (currentFacingMode === "environment") ? "user" : "environment";
                    console.log(`Cambiando a facingMode: ${currentFacingMode}`);
                    await startCamera(currentFacingMode);
                });
            }


            domElements.captureImageButton.addEventListener('click', () => {
                if (currentStream && domElements.cameraFeed.readyState >= 2) {
                    const tempCanvas = document.createElement('canvas');
                    tempCanvas.width = domElements.cameraFeed.videoWidth;
                    tempCanvas.height = domElements.cameraFeed.videoHeight;
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCtx.drawImage(domElements.cameraFeed, 0, 0, tempCanvas.width, tempCanvas.height);
                    const imageDataUrl = tempCanvas.toDataURL('image/jpeg');
                    processImage(imageDataUrl);

                    currentStream.getTracks().forEach(track => track.stop()); currentStream = null;
                    domElements.cameraViewContainer.style.display = 'none';
                } else {
                    setStatusMessage(domElements.statusDiv, "Feed fotocamera non pronto. Riprova.", "warn");
                }
            });

            domElements.closeCameraButton.addEventListener('click', () => {
                if (currentStream) { currentStream.getTracks().forEach(track => track.stop()); currentStream = null; }
                domElements.cameraViewContainer.style.display = 'none';
                setStatusMessage(domElements.statusDiv, "Fotocamera chiusa.", "info");
            });

            if (domElements.bpmSlider && domElements.bpmValueDisplay) {
                domElements.bpmSlider.addEventListener('input', () => {
                    domElements.bpmValueDisplay.textContent = domElements.bpmSlider.value;
                    initialPreselectionDoneForCurrentImage = true;
                    if (currentImage && imageAnalysisResults) { updateAIDisplayAndStablePrompt(); }
                });
            }

            domElements.generateMusicButton.addEventListener('click', async () => {
                console.log("LOG: Pulsante 'Avvia generazione musica' cliccato.");
                if (!currentImage) {
                    console.warn("WARN: Tentativo di generare musica senza currentImage.");
                    setStatusMessage(domElements.statusDiv, "Carica o scatta prima un'immagine.", "error");
                    updateProgressMessage("", false); domElements.dynamicFeedbackArea.style.display = 'none'; return;
                }
                if (!stableAudioPromptForMusic || stableAudioPromptForMusic.toLowerCase().includes("errore") || stableAudioPromptForMusic.toLowerCase().includes("data analysis not available")) {
                    console.log("LOG: Prompt non pronto, richiamo updateAIDisplayAndStablePrompt per finalizzarlo.");
                    await updateAIDisplayAndStablePrompt();
                    if (!stableAudioPromptForMusic || stableAudioPromptForMusic.toLowerCase().includes("errore") || stableAudioPromptForMusic.toLowerCase().includes("data analysis not available")) {
                        console.error("ERRORE: Prompt ancora non valido dopo il tentativo di finalizzazione.");
                        updateProgressMessage("Errore nella preparazione del prompt. Riprova o seleziona un'immagine.", false); return;
                    }
                }


                setStatusMessage(domElements.statusDiv, "Elaborazione in corso...", "info");
                domElements.dynamicFeedbackArea.style.display = 'block';
                updateProgressMessage(`Preparazione e invio richiesta...`, true);
                domElements.generateMusicButton.disabled = true;
                domElements.musicSpinner.style.display = 'inline-block';
                domElements.downloadAudioLink.style.display = 'none';
                domElements.downloadCompositeImageLink.style.display = 'none';
                domElements.downloadQrOnlyLink.style.display = 'none';
                console.log("LOG: Interfaccia aggiornata per lo stato di caricamento.");


                const promptForMusic = stableAudioPromptForMusic;
                const selectedDurationRadio = document.querySelector('input[name="musicDuration"]:checked');
                const duration = selectedDurationRadio ? parseInt(selectedDurationRadio.value) : 20;
                const steps = 30;
                console.log(`LOG: Parametri per generazione musica (Prompt INGLESE): prompt="${promptForMusic}", duration=${duration}, steps=${steps}`);


                try {
                    updateProgressMessage(`Generazione traccia audio (può richiedere tempo)...`, true);
                    console.log("LOG: Inizio fetch a ./generate_music.php");
                    const response = await fetch('./generate_music.php', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ prompt: promptForMusic, duration: duration, steps: steps })
                    });
                    console.log(`LOG: Risposta fetch ricevuta. Status: ${response.status}`);

                    const contentType = response.headers.get("content-type");
                    if (response.ok && contentType && contentType.indexOf("application/json") !== -1) {
                        const result = await response.json();
                        console.log("LOG DEBUG SERVER: Risposta JSON dal server:", result);

                        if (result.success && result.audioUrl) {
                            console.log("LOG: Generazione audio AVVENUTA CON SUCCESSO. URL Audio:", result.audioUrl);
                            domElements.dynamicFeedbackArea.style.display = 'block';
                            domElements.progressMessage.style.display = 'none';
                            domElements.progressBarContainer.style.display = 'none';
                            setStatusMessage(domElements.statusDiv, "Musica generata!", "success");
                            setTimeout(() => {
                                if (domElements.statusDiv.textContent === "Musica generata!") {
                                    domElements.statusDiv.style.display = 'none';
                                }
                            }, 3000);


                            domElements.audioPlayer.src = result.audioUrl;
                            domElements.audioInfo.textContent = `Traccia: ${result.fileName || 'audio_generato'}. ${result.message || ''}`;
                            domElements.downloadAudioLink.href = result.downloadUrl || result.audioUrl;
                            domElements.downloadAudioLink.download = result.fileName || `generated_audio_${Date.now()}.mp3`;
                            domElements.downloadAudioLink.style.display = 'inline-flex';
                            domElements.audioPlayerContainer.style.display = 'block';

                            console.log("LOG DEBUG QR: Inizio processo generazione QR e immagine composita.");
                            if (currentImage && currentImage.complete && currentImage.naturalWidth > 0 && currentImage.naturalHeight > 0 && typeof QRCode !== 'undefined' && result.audioUrl) {
                                const qrCanvasForComposite = document.createElement('canvas');
                                const qrCanvasForSoloDownload = document.createElement('canvas');
                                let desiredQrPixelSize = Math.max(50, Math.min(currentImage.naturalWidth * 0.25, currentImage.naturalHeight * 0.25, 150));
                                console.log("LOG DEBUG QR: Dimensione desiderata per QR Code (pixels):", desiredQrPixelSize);

                                try {
                                    await generateQrCodeToCanvas(qrCanvasForComposite, result.audioUrl, desiredQrPixelSize);
                                    const compositeImageDataUrl = await createCompositeImage(currentImage, qrCanvasForComposite, domElements.compositeImageCanvas);

                                    const placeholder = domElements.downloadCompositeImageLink.querySelector('.button-icon-placeholder');
                                    if (placeholder) {
                                        placeholder.innerHTML = '';
                                        const miniImg = document.createElement('img');
                                        miniImg.src = compositeImageDataUrl;
                                        miniImg.alt = 'Preview';
                                        placeholder.appendChild(miniImg);
                                    }

                                    domElements.downloadCompositeImageLink.href = compositeImageDataUrl;
                                    domElements.downloadCompositeImageLink.download = `pictosound_img_qr_${Date.now()}.png`;
                                    domElements.downloadCompositeImageLink.style.display = 'inline-flex';
                                    console.log("LOG DEBUG QR: Pulsante download immagine composita reso VISIBILE e icona aggiornata.");

                                    const soloQrCanvas = await generateQrCodeToCanvas(qrCanvasForSoloDownload, result.audioUrl, 150);
                                    const soloQrDataUrl = soloQrCanvas.toDataURL('image/png');
                                    domElements.downloadQrOnlyLink.href = soloQrDataUrl;
                                    domElements.downloadQrOnlyLink.download = `pictosound_qrcode_${Date.now()}.png`;
                                    domElements.downloadQrOnlyLink.style.display = 'inline-flex';
                                    console.log("LOG DEBUG QR: Pulsante download solo QR Code reso VISIBILE.");

                                } catch (qrError) {
                                    console.error("ERRORE DETTAGLIATO durante la creazione dell'immagine composita o QR:", qrError);
                                    if (qrError.stack) {
                                        console.error("Stack trace errore QR:", qrError.stack);
                                    }
                                    domElements.downloadCompositeImageLink.style.display = 'none';
                                    domElements.downloadQrOnlyLink.style.display = 'none';
                                    console.log("LOG DEBUG QR: Pulsanti download QR NASCOSTI a causa di errore.");
                                }
                            } else {
                                console.warn("WARN DEBUG QR: Condizioni per la generazione del QR Code non soddisfatte (manca immagine, QRCode lib, o audioUrl).");
                                domElements.downloadCompositeImageLink.style.display = 'none';
                                domElements.downloadQrOnlyLink.style.display = 'none';
                                console.log("LOG DEBUG QR: Pulsanti download QR NASCOSTI a causa di condizioni non soddisfatte.");
                            }

                        } else {
                            console.error("ERRORE: Risposta JSON dal server indica fallimento o URL audio mancante:", result);
                            updateProgressMessage(`Errore dall'API: ${result.error || "URL audio mancante o fallimento"} (HTTP ${response.status})`, false);
                            setStatusMessage(domElements.statusDiv, `Errore API: ${result.error || "Dettagli non disponibili"}`, "error");
                        }
                    } else if (response.ok && contentType && contentType.indexOf("audio/") !== -1) {
                        console.warn("WARN: Risposta audio diretta dal server (non JSON). Il QR code potrebbe non funzionare come previsto.");
                        domElements.dynamicFeedbackArea.style.display = 'block';
                        domElements.progressMessage.style.display = 'none'; domElements.progressBarContainer.style.display = 'none';
                        setStatusMessage(domElements.statusDiv, "Musica generata (formato diretto)!", "success");
                        setTimeout(() => { if (domElements.statusDiv.textContent === "Musica generata (formato diretto)!") domElements.statusDiv.style.display = 'none'; }, 3000);

                        const audioBlob = await response.blob(); const audioUrlForPlayer = URL.createObjectURL(audioBlob);
                        domElements.audioPlayer.src = audioUrlForPlayer; domElements.audioInfo.textContent = `Traccia audio generata.`;
                        domElements.downloadAudioLink.href = audioUrlForPlayer; domElements.downloadAudioLink.download = `pictosound_audio_${Date.now()}.mp3`;
                        domElements.downloadAudioLink.style.display = 'inline-flex'; domElements.audioPlayerContainer.style.display = 'block';
                        domElements.downloadCompositeImageLink.style.display = 'none';
                        domElements.downloadQrOnlyLink.style.display = 'none';
                    }
                    else {
                        const errorText = await response.text();
                        console.error(`ERRORE: Risposta non OK dal server. Status: ${response.status}. Testo: ${errorText}`);
                        updateProgressMessage(`Errore server (HTTP ${response.status}). Dettagli: ${errorText.substring(0, 100)}...`, false);
                        setStatusMessage(domElements.statusDiv, `Errore server (HTTP ${response.status})`, "error");
                    }
                } catch (error) {
                    console.error("ERRORE CRITICO nel blocco try/catch di generateMusicButton:", error);
                    updateProgressMessage("Errore di comunicazione con il server: " + error.message, false);
                    setStatusMessage(domElements.statusDiv, "Errore di comunicazione.", "error");
                } finally {
                    domElements.generateMusicButton.disabled = false;
                    domElements.musicSpinner.style.display = 'none';
                    console.log("LOG: Operazioni di generazione musica (o tentativo) concluse.");
                }
            });

            // Accordion for "Dettagli" in AI Insights
            if (domElements.detailsAccordionHeader && domElements.aiInsightsContent) {
                domElements.detailsAccordionHeader.addEventListener('click', () => {
                    const isOpen = domElements.detailsAccordionHeader.classList.toggle('open');
                    domElements.aiInsightsContent.style.display = isOpen ? 'block' : 'none';
                });
            }

            // Accordions for Cue Selection Groups
            document.querySelectorAll('.cues-selection-container label.group-label.collapsible-cue-header').forEach(header => {
                header.addEventListener('click', () => {
                    header.classList.toggle('open');
                    const content = header.nextElementSibling;
                    if (content && content.classList.contains('checkbox-pills-group')) {
                        content.classList.toggle('open');
                        const bpmSliderContainer = header.parentElement.querySelector('.bpm-slider-container');
                        if (bpmSliderContainer) {
                            bpmSliderContainer.style.display = header.classList.contains('open') ? 'block' : 'none';
                        }
                    }
                });
            });

            // Fullscreen image on audio play
            if (domElements.audioPlayer && domElements.fullscreenImageModal && domElements.fullscreenImage && domElements.closeFullscreenButton) {
                domElements.audioPlayer.onplay = () => {
                    if (currentImageSrc) {
                        domElements.fullscreenImage.src = currentImageSrc;
                        domElements.fullscreenImageModal.style.display = 'flex';
                    }
                };
                domElements.closeFullscreenButton.onclick = () => {
                    domElements.fullscreenImageModal.style.display = 'none';
                };
                window.onclick = (event) => {
                    if (event.target == domElements.fullscreenImageModal) {
                        domElements.fullscreenImageModal.style.display = 'none';
                    }
                };
                document.addEventListener('keydown', function (event) {
                    if (event.key === "Escape") {
                        domElements.fullscreenImageModal.style.display = 'none';
                    }
                });
            }
        });
    </script>
</body>

</html>